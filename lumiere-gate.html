<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>リュミエールの間 | Lumiere Gate</title>
  <style>
    :root {
      --silver: #f3f5ff;
      --lavender: #d9d7ff;
      --lavender-veil: rgba(217, 215, 255, 0.35);
      --pearl: rgba(255, 255, 255, 0.82);
      --gold: #f3d9a3;
      --gold-soft: rgba(243, 217, 163, 0.6);
      --text: #1b1e2a;
      --dialog-max: 900px;
      --shadow: 0 12px 32px rgba(12, 12, 20, 0.25);
      --shadow-soft: 0 8px 20px rgba(12, 12, 20, 0.12);
      --transition: 900ms ease;
      --font-ja: "Hiragino Sans", "Noto Sans JP", "Yu Gothic", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;

      /* ✅ 位置調整：バストアップを少し下げてセリフとのバランス最適化 */
      --lumiere-bust-bottom: 22vh;

      /* 口の微調整（必要なら） */
      --lumiere-mouth-x: 0px;
      --lumiere-mouth-y: 0px;
      --lumiere-mouth-scale: 1;
    }

    *, *::before, *::after { box-sizing: border-box; }

    html, body {
      margin: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
      color: var(--text);
      font-family: var(--font-ja);
      -webkit-font-smoothing: antialiased;
      text-rendering: optimizeLegibility;
    }

    body {
      position: relative;
      background:
        radial-gradient(circle at 30% 15%, rgba(255, 255, 255, 0.3), transparent 35%),
        radial-gradient(circle at 80% 0%, rgba(255, 255, 255, 0.25), transparent 45%),
        linear-gradient(180deg, #0e0f1a 0%, #0a0b14 40%, #0b0c16 100%);
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    }

    main {
      width: 100%;
      height: 100%;
      position: relative;
      overflow: hidden;
    }

    /* 星粒レイヤー */
    .star-field {
      position: fixed;
      inset: 0;
      pointer-events: none;
      overflow: hidden;
      z-index: 1;
    }
    .star-field span {
      position: absolute;
      display: block;
      background: radial-gradient(circle, rgba(255,255,255,0.9) 0, rgba(255,255,255,0.2) 45%, transparent 70%);
      border-radius: 50%;
      animation: drift 18s linear infinite;
      opacity: 0.8;
      filter: blur(0.2px);
    }
    @keyframes drift {
      0% { transform: translate3d(0, 0, 0) scale(1); opacity: 0.2; }
      50% { opacity: 0.8; }
      100% { transform: translate3d(0, -40px, 0) scale(1.15); opacity: 0.15; }
    }

    /* シーン共通 */
    .scene {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      transition: opacity var(--transition);
      opacity: 0;
      pointer-events: none;
      z-index: 2;
    }

    .scene::after {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(180deg, rgba(5, 7, 16, 0.55) 0%, rgba(17, 18, 35, 0.35) 45%, rgba(38, 35, 58, 0.35) 100%);
      pointer-events: none;
    }

    .scene.is-active {
      opacity: 1;
      pointer-events: auto;
    }

    /* フォイヤー */
    .scene-foyer { background-image: url('img/foyer-lumiere.jpg'); }

    .welcome-text {
      position: relative;
      text-align: center;
      color: #fdfbff;
      text-shadow:
        0 0 12px rgba(255, 255, 255, 0.65),
        0 0 24px rgba(243, 217, 163, 0.45);
      font-size: clamp(18px, 3vw, 26px);
      line-height: 1.8;
      letter-spacing: 0.08em;
      opacity: 0;
      transform: translateY(10px);
      transition: opacity 900ms ease, transform 900ms ease;
      z-index: 3;
      padding: 16px 22px;
    }
    .welcome-text.show { opacity: 1; transform: translateY(0); }

    /* ホール */
    .scene-hall { background-image: url('img/lumiere-hall.jpg'); }

    .hall-overlay {
      position: absolute;
      inset: 0;
      background:
        radial-gradient(circle at 50% 30%, rgba(255, 255, 255, 0.15), transparent 45%),
        radial-gradient(circle at 20% 70%, rgba(255, 229, 210, 0.16), transparent 45%),
        linear-gradient(180deg, rgba(10, 9, 25, 0.35), rgba(10, 9, 25, 0.48));
      pointer-events: none;
      z-index: 2;
    }

    /* 全身リュミエール（初回の導入用） */
    .lumiere-full {
      position: absolute;
      bottom: 8vh;
      left: 50%;
      transform: translateX(-50%) translateY(10px);
      opacity: 0;
      max-width: min(60vh, 70vw);
      transition: opacity 800ms ease, transform 1600ms ease;
      z-index: 3;
      animation: float 9s ease-in-out infinite;
    }
    .lumiere-full.show {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }
    @keyframes float {
      0% { transform: translateX(-50%) translateY(0); }
      50% { transform: translateX(-50%) translateY(-8px); }
      100% { transform: translateX(-50%) translateY(0); }
    }

    /* バストアップ（会話用） */
    .lumiere-bust {
      position: absolute;
      bottom: calc(var(--lumiere-bust-bottom) + env(safe-area-inset-bottom, 0px));
      left: 50%;
      transform: translateX(-50%);
      max-width: min(58vh, 78vw);
      opacity: 0;
      transition: opacity 800ms ease;
      z-index: 4; /* セリフより奥 */
      animation: gentleFloat 6s ease-in-out infinite;
      filter: drop-shadow(0 0 10px rgba(255,255,255,0.55));
    }
    .lumiere-bust.is-visible { opacity: 1; }
    .lumiere-bust.speaking { filter: drop-shadow(0 0 16px rgba(255,255,255,0.8)); }

    @keyframes gentleFloat {
      0% { transform: translateX(-50%) translateY(2px); }
      50% { transform: translateX(-50%) translateY(-6px); }
      100% { transform: translateX(-50%) translateY(2px); }
    }

    /* ========= 顔レイヤー方式（確実に表示される構造） ========= */
    .lumiere-bust .frame.lumiere-face{
      position: relative;
      width: min(80vw, 420px);
      margin: 0 auto;
      display: inline-block;
    }

    /* ベース */
    .lumiere-base{
      display: block;
      width: 100%;
      height: auto;
      user-select: none;
      -webkit-user-drag: none;
      pointer-events: none;
    }

    /* 目・口は上に重ねる */
    .lumiere-layer{
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
      pointer-events: none;
      user-select: none;
      -webkit-user-drag: none;
    }

    .lumiere-layer.mouth{
      transform: translate(var(--lumiere-mouth-x), var(--lumiere-mouth-y)) scale(var(--lumiere-mouth-scale));
      transform-origin: center;
    }

    /* セリフウィンドウ */
    .dialogue-window {
      position: absolute;
      left: 50%;
      bottom: 6vh;
      transform: translateX(-50%);
      width: min(var(--dialog-max), 92vw);
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.75), rgba(255, 255, 255, 0.58));
      border: 1px solid rgba(243, 217, 163, 0.6);
      border-radius: 16px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(12px);
      padding: clamp(14px, 3vw, 18px);
      color: #1b1e2a;
      z-index: 5;
      opacity: 0;
      transition: opacity 600ms ease;
      pointer-events: none;
    }
    .dialogue-window.is-visible { opacity: 1; pointer-events: auto; }

    .dialogue-name {
      font-size: 14px;
      letter-spacing: 0.08em;
      color: #6c5c2c;
      margin-bottom: 6px;
    }
    .dialogue-text {
      white-space: pre-line;
      font-size: clamp(15px, 2.5vw, 17px);
      line-height: 1.7;
      min-height: 3.4em;
    }
    .dialogue-next {
      position: absolute;
      right: 14px;
      bottom: 10px;
      font-size: 13px;
      color: #876c2b;
      text-shadow: 0 0 8px rgba(243, 217, 163, 0.7);
      opacity: 0;
      animation: blink 1.4s ease-in-out infinite;
      user-select: none;
    }
    @keyframes blink { 0%, 60% { opacity: 0; } 100% { opacity: 1; } }

    /* 名前入力 */
    .name-input {
      margin-top: 12px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }
    .name-input label { font-size: 14px; color: #3b3b52; }
    .name-input input {
      flex: 1 1 180px;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid rgba(27, 30, 42, 0.2);
      font-size: 15px;
      font-family: var(--font-ja);
      background: rgba(255, 255, 255, 0.8);
      outline: none;
      transition: border-color 160ms ease, box-shadow 160ms ease;
    }
    .name-input input:focus {
      border-color: rgba(243, 217, 163, 0.8);
      box-shadow: 0 0 0 3px rgba(243, 217, 163, 0.25);
    }
    .name-input .error {
      width: 100%;
      color: #8a1f2d;
      font-size: 13px;
      margin-top: -4px;
    }

    .gold-button {
      position: relative;
      border: 1px solid rgba(243, 217, 163, 0.8);
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.86), rgba(232, 225, 255, 0.8));
      color: #725c1b;
      border-radius: 14px;
      padding: 11px 18px;
      font-size: 15px;
      letter-spacing: 0.05em;
      cursor: pointer;
      box-shadow: var(--shadow-soft);
      overflow: hidden;
      transition: transform 160ms ease, box-shadow 160ms ease;
      font-family: var(--font-ja);
      z-index: 1;
    }
    .gold-button:focus-visible { outline: 2px solid rgba(243, 217, 163, 0.8); outline-offset: 2px; }
    .gold-button:hover, .gold-button:active { transform: translateY(-1px); box-shadow: 0 12px 30px rgba(111, 92, 24, 0.25); }
    .gold-button::after {
      content: "";
      position: absolute;
      inset: -20%;
      background: radial-gradient(circle, rgba(255, 255, 255, 0.45), transparent 50%);
      opacity: 0;
      transform: translateY(20px);
      transition: opacity 220ms ease, transform 220ms ease;
      pointer-events: none;
      z-index: 1;
    }
    .gold-button:hover::after, .gold-button:active::after { opacity: 1; transform: translateY(0); }

    /* 足元から光の柱エフェクト */
    .button-column-glow {
      position: absolute;
      left: 50%;
      bottom: -30%;
      transform: translateX(-50%);
      width: 140%;
      height: 180%;
      background:
        radial-gradient(circle at 50% 100%, rgba(255,255,255,0.95), transparent 60%),
        linear-gradient(180deg, rgba(255,255,255,0), rgba(255,255,255,0.9), rgba(255,255,255,0));
      opacity: 0;
      pointer-events: none;
      mix-blend-mode: screen;
      filter: blur(1.5px);
      z-index: 2;
      animation: riseColumn 700ms ease-out forwards;
    }
    @keyframes riseColumn {
      0% { opacity: 0; transform: translateX(-50%) translateY(24px); }
      30% { opacity: 1; }
      100% { opacity: 0; transform: translateX(-50%) translateY(-36px); }
    }

    .particle-layer {
      position: absolute;
      inset: 0;
      overflow: hidden;
      pointer-events: none;
      z-index: 0;
    }
    .particle-layer span {
      position: absolute;
      width: 6px;
      height: 6px;
      background: radial-gradient(circle, rgba(255,255,255,0.9) 0, rgba(243, 217, 163, 0.7) 40%, transparent 70%);
      border-radius: 50%;
      opacity: 0;
      animation: sparkle 1200ms ease-out forwards;
    }
    @keyframes sparkle {
      0% { transform: translateY(12px) scale(0.6); opacity: 0; }
      30% { opacity: 1; }
      100% { transform: translateY(-16px) scale(1); opacity: 0; }
    }

    /* メニュー */
    .menu {
      position: absolute;
      left: 50%;
      bottom: 3vh;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      justify-content: center;
      width: min(960px, 94vw);
      z-index: 6;
      opacity: 0;
      transition: opacity 600ms ease;
      pointer-events: none;
    }
    .menu.is-visible { opacity: 1; pointer-events: auto; }

    /* サウンドボタン */
    .sound-toggle {
      position: fixed;
      top: 14px;
      right: 14px;
      width: 44px;
      height: 44px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.6);
      border: 1px solid rgba(243, 217, 163, 0.7);
      box-shadow: 0 6px 18px rgba(0,0,0,0.18);
      display: grid;
      place-items: center;
      cursor: pointer;
      z-index: 20;
      transition: transform 140ms ease, box-shadow 140ms ease;
    }
    .sound-toggle:hover { transform: translateY(-1px); box-shadow: 0 8px 20px rgba(0,0,0,0.2); }
    .sound-toggle:active { transform: translateY(0); }
    .sound-toggle span {
      font-size: 18px;
      color: #5b4a1c;
      text-shadow: 0 0 6px rgba(243, 217, 163, 0.7);
      user-select: none;
    }

    /* 画面暗転用 */
    .overlay-dim {
      position: fixed;
      inset: 0;
      background: rgba(6, 7, 16, 0.65);
      z-index: 18;
      opacity: 0;
      pointer-events: none;
      transition: opacity 280ms ease;
      display: grid;
      place-items: center;
      color: #fdfbff;
      text-align: center;
      padding: 20px;
      font-size: 16px;
    }
    .overlay-dim.show { opacity: 1; pointer-events: auto; }

    /* スマホ調整 */
    @media (max-width: 720px) {
      .dialogue-window { bottom: 8vh; border-radius: 14px; }
      .menu { bottom: 3vh; gap: 10px; }
      .gold-button { width: calc(50% - 8px); justify-content: center; text-align: center; }
      .name-input { flex-direction: column; align-items: stretch; }
      .name-input input { width: 100%; }
      :root { --lumiere-bust-bottom: 20vh; }
    }
    @media (max-width: 480px) {
      .lumiere-full { bottom: 4vh; }
      .dialogue-window { padding: 12px 14px 18px; }
      :root { --lumiere-bust-bottom: 18vh; }
    }
    @media (max-height: 700px) {
      .dialogue-window { bottom: 10vh; }
      .menu { bottom: 2.4vh; }
      :root { --lumiere-bust-bottom: 16vh; }
    }
  </style>
</head>

<body>
  <script src="/js/common.js"></script>

  <div class="star-field" aria-hidden="true"></div>

  <main>
    <section class="scene scene-foyer is-active" aria-label="静かな前室">
      <div class="welcome-text" id="welcomeText">
        <div>……ようこそ。</div>
        <div>ここは、リュミエールの間——星の記憶が静かに灯る場所。</div>
      </div>
    </section>

    <section class="scene scene-hall" aria-label="リュミエールの間">
      <div class="hall-overlay"></div>

      <!-- 全身 → 初回のみ使用 -->
      <img src="img/lumiere-full.png" alt="リュミエール全身" class="lumiere-full" id="fullFigure">

      <!-- ✅ バストアップ（faceは通常配置、目と口を重ねる） -->
      <div class="lumiere-bust" id="bustContainer" aria-hidden="true">
        <div class="frame lumiere-face" id="lumiereFaceFrame">
          <img class="lumiere-base" src="assets/lumiere/face.png" alt="Lumiere face">
          <img class="lumiere-layer eyes"  id="lumiereEyes"  src="assets/lumiere/eyes_open.png" alt="">
          <img class="lumiere-layer mouth" id="lumiereMouth" src="assets/lumiere/mouth.png" alt="">
        </div>
      </div>

      <!-- セリフ -->
      <div class="dialogue-window" id="dialogueWindow" aria-live="polite">
        <div class="dialogue-name">Lumiere</div>
        <div class="dialogue-text" id="dialogueText"></div>
        <div class="dialogue-next" id="dialogueNext">▶</div>

        <div class="name-input" id="nameInput" style="display:none;">
          <label for="visitorName">あなた様のお名前</label>
          <input id="visitorName" name="visitorName" type="text" maxlength="20" aria-label="お名前入力欄">
          <button class="gold-button" id="nameSubmit" aria-label="この名前で呼んで">この名前で呼んで</button>
          <div class="error" id="nameError" aria-live="assertive"></div>
        </div>
      </div>

      <!-- メニュー -->
      <div class="menu" id="menu">
        <button class="gold-button" data-action="pray" aria-label="セレフィアスに祈りを捧げる">
          セレフィアスに祈りを捧げる
          <div class="particle-layer"></div>
        </button>

        <button class="gold-button" data-action="village" aria-label="始まりの町に行く" style="display:none;">
          始まりの町に行く
          <div class="particle-layer"></div>
        </button>

        <button class="gold-button" data-action="talk" aria-label="リュミエールと話す">
          リュミエールと話す
          <div class="particle-layer"></div>
        </button>
      </div>
    </section>
  </main>

  <button class="sound-toggle" id="soundToggle" aria-label="BGM 切り替え"><span>♪</span></button>
  <div class="overlay-dim" id="dimOverlay"></div>
  <audio id="bgm" src="audio/lumiere-theme.mp3" loop preload="auto"></audio>

  <script>
    (() => {
      "use strict";

      const starField      = document.querySelector(".star-field");
      const sceneFoyer     = document.querySelector(".scene-foyer");
      const sceneHall      = document.querySelector(".scene-hall");
      const welcomeText    = document.getElementById("welcomeText");
      const fullFigure     = document.getElementById("fullFigure");
      const bustContainer  = document.getElementById("bustContainer");

      const lumiereEyes  = document.getElementById("lumiereEyes");
      const lumiereMouth = document.getElementById("lumiereMouth");

      const dialogueWindow = document.getElementById("dialogueWindow");
      const dialogueText   = document.getElementById("dialogueText");
      const dialogueNext   = document.getElementById("dialogueNext");
      const nameInput      = document.getElementById("nameInput");
      const nameError      = document.getElementById("nameError");
      const nameField      = document.getElementById("visitorName");
      const nameSubmit     = document.getElementById("nameSubmit");
      const menu           = document.getElementById("menu");
      const menuButtons    = menu.querySelectorAll("button");
      const soundToggle    = document.getElementById("soundToggle");
      const bgm            = document.getElementById("bgm");
      const dimOverlay     = document.getElementById("dimOverlay");

      const STORAGE_MUTE = "lumiereBgmMuted";
      const blinkMin = 3000;
      const blinkMax = 7000;

      // =========================================================
      // 名前
      // =========================================================
      const stripHonorific = (s) => {
        return String(s || "").trim().replace(/(様|さま|さん|ちゃん|くん)+$/u, "").trim();
      };

      const normalizeBaseName = (s) => {
        const base = stripHonorific(s);
        if (!base) return "";
        if (/^(ゲスト|guest)$/i.test(base)) return "";
        return base;
      };

      const getBaseUserName = () => {
        if (typeof window.getUserName === "function") {
          return normalizeBaseName(window.getUserName());
        }
        return normalizeBaseName(localStorage.getItem("sv_user_name") || "");
      };

      const injectName = (arr) => {
        const base = getBaseUserName();
        const honor = base ? `${base}様` : "";
        return (arr || []).map((line) => {
          let s = String(line);
          s = s.replace(/\{name\}(様|さま)/gu, () => (base ? `${base}様` : ""));
          s = s.replace(/\{nameWithHonor\}/g, honor);
          s = s.replace(/\{name\}/g, base);
          return s;
        });
      };

      // =========================================================
      // セリフ（TXTがあれば上書き）
      // ✅ talk は「空行区切り」で1ブロック（2〜3行）＝1会話
      // =========================================================
      const fallbackLines = {
        "first-visit": [
          "……聞こえていますか？",
          "あなた様の足音が、この星の間まで届いたの。",
          "静かな光が揺れて……あなた様を迎えているみたい。"
        ],
        "ask-name": [
          "ねぇ……あなた様のお名前を、わたしに教えてくれる？",
          "呼ぶたびに、胸の奥があたたかくなるような……そんな響きを。"
        ],
        "after-name": [
          "……{nameWithHonor}。",
          "うん……とても、きれいな音。",
          "これからは、そのお名前で呼ばせてくださいね。"
        ],
        "revisit": [
          "おかえりなさい、{nameWithHonor}。",
          "またひとつ、静かな光が灯りました。"
        ],
        "conversation": [
          "……{nameWithHonor}。今日は……少し話してもいい？",
          "最近ね……星たちが、少しだけざわめいているの。",
          "でも、大丈夫。あなた様が来てくれると、",
          "この間は……なんだか落ち着くの。",
          "疲れたら、いつでもここで休んでくださいね。"
        ],
        /* ✅ 内部の talk も「ブロック」前提にしておく（空行＝区切り） */
        "talk": [
          "……{nameWithHonor}。",
          "今日の心は、どんな天気かな。",
          "雲があっても、空はちゃんとここにあるよ。",
          "",
          "焦りがある日は、光が少し細く見える。",
          "でもね、細い光でも――",
          "道を照らすには、十分なんだよ。",
          "",
          "涙は弱さじゃない。",
          "光が溢れただけ。",
          "だから、隠さなくていい。"
        ]
      };

      let externalLines = {};
      let currentLines = [];
      let lineIndex = 0;
      let typingTimer = null;
      let isTyping = false;
      let isConversation = false;

      // talk：重複なしランダム（ブロック単位）
      let talkQueue = [];

      /* ✅ 空行を保持できるTXTパーサ（talkのブロック区切りに必要） */
      const parseLumiereTxt = (txt) => {
        const lines = {};
        let current = null;

        txt.split("\n").forEach((raw) => {
          const line = raw.replace(/\r/g, ""); // 念のため
          const trimmed = line.trimEnd();      // 右端だけ整える（空行判定に使う）

          if (trimmed.trim().startsWith("# ")) {
            current = trimmed.trim().replace("# ", "").trim();
            lines[current] = [];
            return;
          }

          if (!current) return;

          // ✅ 空行は「区切り」として保持（"" を入れる）
          if (trimmed.trim() === "") {
            lines[current].push("");
            return;
          }

          // ✅ 通常行
          lines[current].push(trimmed.trim());
        });

        return lines;
      };

      const loadExternalLines = async () => {
        try {
          const res = await fetch("data/lumiere-lines.txt", { cache: "no-store" });
          if (!res.ok) return;
          const txt = await res.text();
          externalLines = parseLumiereTxt(txt);
        } catch (e) {
          console.warn("TXT 読み込み失敗。内部デフォルトを使用します。", e);
        }
      };

      const getLines = (category) => {
        if (externalLines[category] && externalLines[category].length > 0) return externalLines[category];
        return fallbackLines[category] || [];
      };

      /* ✅ talk を「空行区切り」でブロック化する（2〜3行×2〜3ターン運用OK） */
      const splitIntoBlocks = (rawLines) => {
        const src = Array.isArray(rawLines) ? rawLines : [];
        const blocks = [];
        let buf = [];

        const pushBuf = () => {
          const clean = buf.map(s => String(s || "").trim()).filter(Boolean);
          if (clean.length) blocks.push(clean);
          buf = [];
        };

        for (const line of src) {
          const s = String(line ?? "");
          if (s.trim() === "") {
            pushBuf();
          } else {
            buf.push(s);
          }
        }
        pushBuf();

        // もし「空行区切りが無い」＝旧形式だった場合は、1行=1ブロック扱いに寄せる
        if (blocks.length === 0) {
          return src.map(s => String(s || "").trim()).filter(Boolean).map(one => [one]);
        }
        return blocks;
      };

      // =========================================================
      // 星粒
      // =========================================================
      const createStars = () => {
        const total = 40;
        for (let i = 0; i < total; i++) {
          const s = document.createElement("span");
          const size = Math.random() * 3 + 1;
          s.style.width = `${size}px`;
          s.style.height = `${size}px`;
          s.style.left = `${Math.random() * 100}%`;
          s.style.top = `${Math.random() * 100}%`;
          s.style.animationDuration = `${14 + Math.random() * 10}s`;
          s.style.animationDelay = `${Math.random() * 12}s`;
          starField.appendChild(s);
        }
      };

      // =========================================================
      // 粒子＆光柱
      // =========================================================
      const spawnParticles = (btn) => {
        const layer = btn.querySelector(".particle-layer");
        if (!layer) return;
        layer.innerHTML = "";
        for (let i = 0; i < 6; i++) {
          const p = document.createElement("span");
          p.style.left = `${20 + Math.random() * 60}%`;
          p.style.top = `${60 + Math.random() * 30}%`;
          p.style.animationDelay = `${i * 60}ms`;
          layer.appendChild(p);
        }
      };

      const spawnColumnLight = (btn) => {
        const glow = document.createElement("div");
        glow.className = "button-column-glow";
        btn.appendChild(glow);
        glow.addEventListener("animationend", () => glow.remove());
      };

      // =========================================================
      // 目ぱち（open/half/close）
      // =========================================================
      let blinkTimer = null;

      const scheduleBlink = () => {
        clearTimeout(blinkTimer);
        const delay = blinkMin + Math.random() * (blinkMax - blinkMin);

        blinkTimer = setTimeout(() => {
          lumiereEyes.src = "assets/lumiere/eyes_half.png";
          setTimeout(() => {
            lumiereEyes.src = "assets/lumiere/eyes_close.png";
            setTimeout(() => {
              lumiereEyes.src = "assets/lumiere/eyes_open.png";
              scheduleBlink();
            }, 110);
          }, 90);
        }, delay);
      };

      // =========================================================
      // ✅ 口パク：文字追従（自然に喋る）
      // =========================================================
      let mouthPulse = 0;

      const setMouth = (open) => {
        lumiereMouth.src = open ? "assets/lumiere/mouth_open.png" : "assets/lumiere/mouth.png";
      };

      const stopMouth = () => {
        setMouth(false);
      };

      const isPauseChar = (ch) => /[、。…！？\s]/u.test(ch);

      const mouthStepByChar = (ch) => {
        if (!ch) return;
        if (isPauseChar(ch)) { setMouth(false); return; }

        mouthPulse++;
        const mod = mouthPulse % 4;
        if (mod === 0) { setMouth(false); return; }
        setMouth(true);
      };

      const mouthMicroBounce = () => {
        setMouth(true);
        setTimeout(() => setMouth(false), 110);
      };

      const showBust = () => {
        bustContainer.classList.add("is-visible");
        lumiereEyes.src = "assets/lumiere/eyes_open.png";
        stopMouth();
        scheduleBlink();
      };

      const hideBust = () => {
        bustContainer.classList.remove("is-visible");
        clearTimeout(blinkTimer);
        blinkTimer = null;
        stopMouth();
        lumiereEyes.src = "assets/lumiere/eyes_open.png";
      };

      // =========================================================
      // セリフ表示
      // =========================================================
      const resetDialogueHandlers = () => {
        dialogueWindow.onclick = null;
        dialogueNext.onclick = null;
      };

      const setSpeaking = (state) => {
        const on = !!state;
        bustContainer.classList.toggle("speaking", on);
        if (!on) stopMouth();
      };

      const hideDialogueWindow = () => {
        dialogueWindow.classList.remove("is-visible");
        resetDialogueHandlers();
        clearInterval(typingTimer);
        typingTimer = null;
        isTyping = false;
        dialogueNext.style.opacity = 0;
        stopMouth();
        setSpeaking(false);
      };

      const showLine = (line, onComplete) => {
        clearInterval(typingTimer);
        typingTimer = null;
        dialogueNext.style.opacity = 0;

        const chars = Array.from(String(line));
        let idx = 0;
        dialogueText.textContent = "";
        isTyping = true;

        mouthPulse = 0;

        typingTimer = setInterval(() => {
          const ch = chars[idx];
          dialogueText.textContent += ch;
          mouthStepByChar(ch);

          idx++;

          if (idx >= chars.length) {
            clearInterval(typingTimer);
            typingTimer = null;
            isTyping = false;
            mouthMicroBounce();
            dialogueNext.style.opacity = 1;
            if (onComplete) onComplete();
          }
        }, 34);
      };

      const showAll = (line) => {
        clearInterval(typingTimer);
        typingTimer = null;
        isTyping = false;

        dialogueText.textContent = String(line);
        dialogueNext.style.opacity = 1;

        mouthPulse = 0;
        setMouth(true);
        setTimeout(() => setMouth(false), 140);
      };

      const playLines = (list, callback, { keepVisible = false } = {}) => {
        currentLines = Array.isArray(list) ? list.slice() : [];
        lineIndex = 0;

        if (!currentLines.length) {
          if (!keepVisible) hideDialogueWindow();
          if (callback) callback();
          return;
        }

        dialogueWindow.classList.add("is-visible");
        setSpeaking(true);

        const next = () => {
          if (lineIndex >= currentLines.length) {
            resetDialogueHandlers();
            setSpeaking(false);
            if (!keepVisible) hideDialogueWindow();
            if (callback) callback();
            return;
          }
          showLine(currentLines[lineIndex], () => {});
        };

        const advance = () => {
          if (isTyping) { showAll(currentLines[lineIndex]); return; }
          lineIndex++;
          next();
        };

        resetDialogueHandlers();
        dialogueWindow.onclick = advance;
        dialogueNext.onclick = advance;
        next();
      };

      // =========================================================
      // ✅ talk：重複なしランダム（ブロック単位）
      // - TXTの # talk は「空行区切り」で 1ブロック=1会話
      // - ブロック内は行送りで進む
      // - ブロックが終わるまでメニューに戻らない
      // =========================================================
      const shuffle = (arr) => {
        const a = arr.slice();
        for (let i = a.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [a[i], a[j]] = [a[j], a[i]];
        }
        return a;
      };

      const refillTalkQueueIfNeeded = () => {
        if (talkQueue.length > 0) return;

        const raw = getLines("talk");
        const blocks = splitIntoBlocks(raw);

        // talkが無い場合は conversation をブロック化（空行なしなら 1行=1ブロックになる）
        const fallbackBlocks = splitIntoBlocks(getLines("conversation"));

        const pool = (blocks.length ? blocks : fallbackBlocks).filter(b => Array.isArray(b) && b.length);
        talkQueue = shuffle(pool);
      };

      const popNextTalkBlock = () => {
        refillTalkQueueIfNeeded();
        return talkQueue.shift() || [];
      };

      // =========================================================
      // BGM
      // =========================================================
      const setMute = (muted) => {
        bgm.muted = muted;
        soundToggle.querySelector("span").textContent = muted ? "♪×" : "♪";
        localStorage.setItem(STORAGE_MUTE, muted ? "1" : "0");
      };

      const ensureBgm = () => {
        if (bgm.dataset.started) return;
        bgm.dataset.started = "1";
        bgm.volume = 0.6;
        if (!bgm.muted) bgm.play().catch(() => {});
      };

      // =========================================================
      // プリロード
      // =========================================================
      const preloadImages = () => {
        [
          "assets/lumiere/face.png",
          "assets/lumiere/eyes_open.png",
          "assets/lumiere/eyes_half.png",
          "assets/lumiere/eyes_close.png",
          "assets/lumiere/mouth.png",
          "assets/lumiere/mouth_open.png",
        ].forEach((src) => { const img = new Image(); img.src = src; });
      };

      // =========================================================
      // フォイヤー → ホール
      // =========================================================
      const startFoyer = () => {
        dialogueWindow.classList.remove("is-visible");
        menu.classList.remove("is-visible");
        hideBust();

        setTimeout(() => welcomeText.classList.add("show"), 3000);

        setTimeout(() => {
          welcomeText.classList.remove("show");
          sceneFoyer.classList.remove("is-active");
          sceneHall.classList.add("is-active");
          enterHall();
        }, 6200);
      };

      const enterHall = () => {
        fullFigure.classList.add("show");
        setTimeout(() => { runInitialDialogue(); }, 1000);
      };

      // =========================================================
      // 初期セリフ（初回／再訪）
      // =========================================================
      const runInitialDialogue = () => {
        const base = getBaseUserName();

        if (base) {
          fullFigure.classList.remove("show");
          showBust();

          playLines(
            injectName(getLines("revisit")),
            () => {
              hideDialogueWindow();
              isConversation = false;
              setTimeout(() => {
                menu.classList.add("is-visible");
                updateMenuForReturn();
              }, 350);
            }
          );
          return;
        }

        hideBust();
        fullFigure.classList.add("show");

        const firstLines = injectName(getLines("first-visit"));
        const askLines   = injectName(getLines("ask-name"));

        playLines(
          firstLines,
          () => {
            playLines(
              askLines,
              () => {
                nameInput.style.display = "flex";
                nameField.focus();
                resetDialogueHandlers();
              },
              { keepVisible: true }
            );
          },
          { keepVisible: true }
        );
      };

      const showNameFixed = () => {
        const linesToShow = injectName(getLines("after-name"));

        playLines(linesToShow, () => {
          hideDialogueWindow();
          fullFigure.classList.remove("show");

          setTimeout(() => {
            showBust();
            menu.classList.add("is-visible");
            updateMenuForReturn();
          }, 700);
        });
      };

      const updateMenuForReturn = () => {
        const villageBtn = menu.querySelector('[data-action="village"]');
        villageBtn.style.display = (getBaseUserName() ? "inline-flex" : "none");
      };

      // =========================================================
      // ✅ talk：1回押すたびに「1ブロック(2〜3行)」を最後まで
      // - ブロックが終わるまでメニューに戻らない
      // =========================================================
      const startTalkOnce = () => {
        isConversation = true;
        menu.classList.remove("is-visible");

        showBust();

        const block = popNextTalkBlock();     // ← 配列（2〜3行）
        const lines = injectName(block);      // ← 名前差し込み

        playLines(lines, () => { endConversation(); });  // ← 全行終わってから戻る
      };

      const endConversation = () => {
        isConversation = false;
        hideDialogueWindow();
        setTimeout(() => { menu.classList.add("is-visible"); }, 350);
      };

      // =========================================================
      // イベント
      // =========================================================
      nameSubmit.addEventListener("click", () => {
        const value = nameField.value.trim();
        if (!value) { nameError.textContent = "……お名前を教えてくれる？"; return; }
        nameError.textContent = "";

        const clean = normalizeBaseName(value);
        if (!clean) {
          nameError.textContent = "……そのお名前では登録できないの。別のお名前を教えてくださいね。";
          return;
        }

        if (typeof window.setUserName === "function") {
          window.setUserName(clean);
        } else {
          localStorage.setItem("sv_user_name", clean);
          window.ShioponUserName = clean;
        }

        nameInput.style.display = "none";
        showNameFixed();
      });

      menuButtons.forEach((btn) => {
        btn.addEventListener("click", () => {
          spawnParticles(btn);
          spawnColumnLight(btn);
          ensureBgm();

          const action = btn.dataset.action;

          if (action === "pray") {
            dimOverlay.textContent = "静かに祈りを届けています……";
            dimOverlay.classList.add("show");
            setTimeout(() => { window.location.href = "serephias-chamber.html"; }, 900);
          }

          if (action === "village") {
            dimOverlay.textContent = "風の音が、始まりの町へと導きます。";
            dimOverlay.classList.add("show");
            setTimeout(() => { window.location.href = "star-memory.html"; }, 900);
          }

          if (action === "talk") {
            dimOverlay.classList.remove("show");
            if (isConversation) return;
            startTalkOnce();
          }
        });
      });

      soundToggle.addEventListener("click", () => {
        const muted = !(localStorage.getItem(STORAGE_MUTE) === "1");
        setMute(muted);
        ensureBgm();
      });

      document.body.addEventListener("click", ensureBgm, { once: true });

      // =========================================================
      // 初期化
      // =========================================================
      const startLumiereGate = () => {
        createStars();
        preloadImages();
        setMute(localStorage.getItem(STORAGE_MUTE) === "1");

        if (getBaseUserName()) {
          sceneFoyer.classList.remove("is-active");
          sceneHall.classList.add("is-active");
          hideDialogueWindow();
          enterHall();
        } else {
          startFoyer();
        }
      };

      window.addEventListener("DOMContentLoaded", async () => {
        await loadExternalLines();
        talkQueue = [];
        startLumiereGate();
      });
    })();
  </script>
</body>
</html>
