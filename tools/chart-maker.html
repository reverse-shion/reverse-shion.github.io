<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <!-- iOS: viewport drift/zoom対策（必要なら viewport-fit=cover もOK） -->
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>DI Chart Maker — GOD ENGINE (Stable SingleClock)</title>
  <style>
    :root{
      --bg:#0b0f18; --card:#111a2a; --bd:#2a3754; --fg:#e8eeff;
      --mut:#9eb0d8; --btn:#345dff; --btnbd:#4c72ff;
      --ok:#7cffc0; --ng:#ff7a7a;
    }
    body{margin:0;background:var(--bg);color:var(--fg);font:14px/1.45 system-ui;padding:12px}
    .card{background:var(--card);border:1px solid var(--bd);border-radius:12px;padding:12px;margin-bottom:10px}
    label{display:block;font-size:12px;color:var(--mut);margin:10px 0 4px}
    input,select,button,textarea{
      width:100%;box-sizing:border-box;border-radius:10px;border:1px solid #33466d;
      background:#0e1626;color:#eef3ff;padding:10px
    }
    button{background:var(--btn);border-color:var(--btnbd);font-weight:800;cursor:pointer}
    button.secondary{background:#1a2b4d;border-color:#2f4b7d}
    button.danger{background:#5b1d2a;border-color:#8b2d42}
    button:disabled{opacity:.5;cursor:not-allowed}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .row3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px}
    .row4{display:grid;grid-template-columns:1fr 1fr 1fr 1fr;gap:10px}
    .hint{font-size:12px;color:#b8c7ef;opacity:.95;margin-top:6px}
    .mini{font-size:12px;opacity:.9}
    .ok{color:var(--ok)} .ng{color:var(--ng)}
    pre{
      max-height:320px;overflow:auto;background:#0a1220;border:1px solid #273657;
      padding:10px;border-radius:10px;white-space:pre-wrap
    }
    .pill{
      display:inline-block;padding:3px 10px;border:1px solid #2a3754;border-radius:999px;margin:4px 6px 0 0;
      font-size:12px;color:#cfe0ff;background:rgba(255,255,255,.03)
    }
    .statusLine{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin-top:8px}
    .meter{
      font:12px/1.2 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      padding:6px 10px;border:1px solid #2a3754;border-radius:999px;background:rgba(255,255,255,.03)
    }
    .hr{height:1px;background:#2a3754;margin:12px 0;opacity:.85}
    .tag{display:inline-block;font-size:12px;padding:2px 8px;border:1px solid #2a3754;border-radius:999px;background:rgba(255,255,255,.03);margin-right:6px}

    /* REC誤爆回避のため、押せるUI領域を明確化 */
    .uiBlock{ position:relative; z-index:2; }
  </style>
</head>
<body>

  <div class="card uiBlock" id="uiRoot">
    <label>Audio file</label>
    <input id="audioFile" type="file" accept=".mp3,.m4a,.aac,.wav,.caf,.aiff,.mp4,.mov,audio/*,video/*" />
    <div class="hint">
      iOS/Dropbox で type が空のことがあるので拡張子でも判定します。<strong>Files アプリ経由の mp3/m4a 推奨</strong>。
      <br/>このツールは <strong>AudioContext 単一クロック</strong>で「RECタップ」「自動生成」「プレビュー」を完全同期させます。
      <br/><span class="tag">PRO Auto</span>既存の“リズム気持ちいい”生成
      <span class="tag">GOD Auto</span>サビ検出＋密度カーブ＋FEEL統合
    </div>

    <div class="row" style="margin-top:10px">
      <div>
        <label>Mode</label>
        <select id="genMode">
          <option value="pro" selected>PRO Auto（既存）</option>
          <option value="god">GOD Auto（Stage/Feel/Style）</option>
        </select>
        <div class="hint mini">GODは「サビで解放される」密度設計が入る</div>
      </div>
      <div>
        <label>Lane（今は1のみ / 将来3レーン拡張用）</label>
        <select id="laneMode">
          <option value="1" selected>1 Lane</option>
          <option value="3" disabled>3 Lane（coming soon）</option>
        </select>
        <div class="hint mini">内部は拡張できる構造で組んであります</div>
      </div>
    </div>

    <div class="row" style="margin-top:10px">
      <div>
        <label>Stage</label>
        <select id="stage">
          <option value="calm">Calm</option>
          <option value="energy" selected>Energy</option>
          <option value="chaos">Chaos</option>
        </select>
        <div class="hint mini">密度/休符/ピークの出方が変わる（GOD Autoで使用）</div>
      </div>
      <div>
        <label>Style</label>
        <select id="style">
          <option value="stable">Stable</option>
          <option value="groove" selected>Groove</option>
          <option value="technical">Technical</option>
        </select>
        <div class="hint mini">Stable=芯 / Groove=裏拍 / Technical=16分スパイス（GOD Autoで使用）</div>
      </div>
    </div>

    <div class="row" style="margin-top:10px">
      <div>
        <label>FEEL（神譜面スライダー）: <span id="feelV">60</span></label>
        <input id="feel" type="range" min="0" max="100" step="1" value="60" />
        <div class="hint mini">右へ→密度↑/MinGap↓/裏拍↑/16分↑（GOD Autoで使用）</div>
      </div>
      <div>
        <label>Seed（同じ条件で同じ譜面を再現）</label>
        <input id="seed" type="number" min="0" step="1" value="1" />
        <div class="hint mini">神譜面づくりは“再現性”が命。ブレない生成にする</div>
      </div>
    </div>

    <div class="row" style="margin-top:10px">
      <div>
        <label>Grid（吸着）</label>
        <select id="grid">
          <option value="0">OFF</option>
          <option value="4">1/4</option>
          <option value="8" selected>1/8</option>
          <option value="16">1/16</option>
        </select>
        <div class="hint mini">OFF = 人間のノリ / 1/8 = 音ゲーっぽく気持ちいい</div>
      </div>
      <div>
        <label>BPM (0=auto)</label>
        <input id="bpm" type="number" min="0" step="0.1" value="0" />
        <div class="hint mini">自動推定が合わない曲は固定（例: 145）</div>
      </div>
    </div>

    <div class="row" style="margin-top:10px">
      <div>
        <label>Lead-in（入り遅延）: <span id="leadV">1.20</span>s</label>
        <input id="leadIn" type="range" min="0" max="3" step="0.05" value="1.2" />
      </div>
      <div>
        <label>Global Offset（微調整）: <span id="offsetV">0</span>ms</label>
        <input id="offset" type="range" min="-250" max="250" step="1" value="0" />
      </div>
    </div>

    <div class="row" style="margin-top:10px">
      <div>
        <label>Min Gap（詰めすぎ防止）: <span id="minGapV">95</span>ms</label>
        <input id="minGap" type="range" min="40" max="240" value="95" />
      </div>
      <div>
        <label>Kick Bias（低域を叩かせる）: <span id="lowWV">1.25</span></label>
        <input id="lowW" type="range" min="0.2" max="3" step="0.05" value="1.25" />
      </div>
    </div>

    <div class="row" style="margin-top:10px">
      <div>
        <label>Onset Sensitivity（ピーク検出）: <span id="thV">1.55</span></label>
        <input id="threshold" type="range" min="0.8" max="3.6" step="0.05" value="1.55" />
      </div>
      <div>
        <label>“ノリ”補正（裏拍）: <span id="backV">0.14</span></label>
        <input id="backbeat" type="range" min="0" max="0.35" step="0.01" value="0.14" />
      </div>
    </div>

    <div class="row" style="margin-top:10px">
      <div>
        <label>安定補正（強拍）: <span id="downV">0.18</span></label>
        <input id="downbeat" type="range" min="0" max="0.35" step="0.01" value="0.18" />
      </div>
      <div>
        <label>Humanize（前ノリ/溜め）: <span id="humV">0.60</span></label>
        <input id="humanize" type="range" min="0" max="1" step="0.05" value="0.6" />
      </div>
    </div>

    <div class="hr"></div>

    <div class="row3">
      <button id="load" class="secondary">1) Load & Decode</button>
      <button id="auto" class="">2) Auto Generate</button>
      <button id="download" disabled>Download chart.json</button>
    </div>

    <div class="row3" style="margin-top:10px">
      <button id="recStart" class="secondary" disabled>REC Start (Play)</button>
      <button id="recStop" class="danger" disabled>REC Stop</button>
      <button id="buildFromRec" class="" disabled>Build from REC</button>
    </div>

    <div class="row3" style="margin-top:10px">
      <button id="merge" class="secondary" disabled>Merge (Auto + REC)</button>
      <button id="previewPlay" class="secondary" disabled>Preview Play (metronome)</button>
      <button id="clearRec" class="danger" disabled>Clear REC</button>
    </div>

    <div class="row3" style="margin-top:10px">
      <div>
        <label>Download Difficulty（GOD Autoで生成された場合）</label>
        <select id="dlDiff">
          <option value="single" selected>Single (last preview)</option>
          <option value="easy">EASY</option>
          <option value="normal">NORMAL</option>
          <option value="hard">HARD</option>
          <option value="bundle">BUNDLE (easy/normal/hard)</option>
        </select>
        <div class="hint mini">PRO Autoはsingleのみ。GOD Autoは3難易度を保持</div>
      </div>
      <div>
        <label>Auto Level（目安）</label>
        <input id="level" type="text" value="--" readonly />
        <div class="hint mini">生成ノーツ密度から自動算出</div>
      </div>
      <div>
        <label>Chorus Detect（推定）</label>
        <input id="chorusInfo" type="text" value="--" readonly />
        <div class="hint mini">GOD Autoのみ：サビ割合/区間を推定</div>
      </div>
    </div>

    <div class="statusLine">
      <div id="status" class="hint"></div>
      <div class="meter" id="meterA">audio: --</div>
      <div class="meter" id="meterB">bpm: --</div>
      <div class="meter" id="meterC">rec taps: 0</div>
      <div class="meter" id="meterS">state: idle</div>
    </div>

    <div class="hint mini">
      推奨：<span class="pill">Grid 1/8</span>
      <span class="pill">Lead-in 1.0〜1.6s</span>
      <span class="pill">MinGap 85〜110ms</span>
      <span class="pill">Humanize 0.55〜0.70</span>
      <span class="pill">FEEL 55〜75</span>
      <span class="pill">Stage Energy</span>
      <span class="pill">Style Groove</span>
    </div>
  </div>

  <div class="card">
    <strong>Preview JSON</strong>
    <pre id="preview">{}</pre>
  </div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);

  const ui = {
    uiRoot: $("uiRoot"),
    audioFile: $("audioFile"),
    genMode: $("genMode"),
    laneMode: $("laneMode"),
    stage: $("stage"),
    style: $("style"),
    feel: $("feel"),
    feelV: $("feelV"),
    seed: $("seed"),

    grid: $("grid"),
    bpm: $("bpm"),
    leadIn: $("leadIn"),
    offset: $("offset"),
    minGap: $("minGap"),
    threshold: $("threshold"),
    lowW: $("lowW"),
    backbeat: $("backbeat"),
    downbeat: $("downbeat"),
    humanize: $("humanize"),

    leadV: $("leadV"),
    offsetV: $("offsetV"),
    minGapV: $("minGapV"),
    thV: $("thV"),
    lowWV: $("lowWV"),
    backV: $("backV"),
    downV: $("downV"),
    humV: $("humV"),

    load: $("load"),
    auto: $("auto"),
    download: $("download"),

    recStart: $("recStart"),
    recStop: $("recStop"),
    buildFromRec: $("buildFromRec"),
    merge: $("merge"),
    previewPlay: $("previewPlay"),
    clearRec: $("clearRec"),

    dlDiff: $("dlDiff"),
    level: $("level"),
    chorusInfo: $("chorusInfo"),

    status: $("status"),
    meterA: $("meterA"),
    meterB: $("meterB"),
    meterC: $("meterC"),
    meterS: $("meterS"),
    preview: $("preview"),
  };

  // ----------------------------
  // State Machine (事故防止)
  // ----------------------------
  const MODE = Object.freeze({
    IDLE: "idle",
    LOADED: "loaded",
    REC: "rec",
    PREVIEW: "preview",
  });

  const state = {
    mode: MODE.IDLE,
    fileName: "",
    audioBuf: null,
    envPack: null,
    bpm: 0,

    autoChart: null,    // PROのみ
    recChart: null,
    mergedChart: null,

    god: null,          // {meta,easy,normal,hard,bundle}
    lastPayload: null,  // download source of truth
  };

  function setMode(m){
    state.mode = m;
    ui.meterS.textContent = `state: ${m}`;
    refreshButtons();
  }

  function refreshButtons(){
    const hasAudio = !!state.audioBuf;
    const isRec = state.mode === MODE.REC;
    const isPrev = state.mode === MODE.PREVIEW;

    ui.load.disabled = false;

    ui.auto.disabled = !hasAudio || isRec || isPrev;

    ui.recStart.disabled = !hasAudio || isRec || isPrev;
    ui.recStop.disabled = !isRec;

    ui.previewPlay.disabled = !hasAudio || isRec; // previewはrec中禁止
    ui.clearRec.disabled = isRec ? true : false;  // rec中に消す事故防止

    ui.buildFromRec.disabled = !hasAudio || isRec || rec.taps.length === 0;
    ui.merge.disabled = !(state.autoChart && state.recChart) || isRec || isPrev;

    ui.download.disabled = !state.lastPayload || isRec; // REC中DL事故防止
  }

  // ----------------------------
  // UI helpers
  // ----------------------------
  function setStatus(msg, ok=false){
    ui.status.innerHTML = ok ? `<span class="ok">${msg}</span>` : `<span class="ng">${msg}</span>`;
  }
  function upd(){
    ui.feelV.textContent = ui.feel.value;

    ui.leadV.textContent = Number(ui.leadIn.value).toFixed(2);
    ui.offsetV.textContent = ui.offset.value;
    ui.minGapV.textContent = ui.minGap.value;
    ui.thV.textContent = Number(ui.threshold.value).toFixed(2);
    ui.lowWV.textContent = Number(ui.lowW.value).toFixed(2);
    ui.backV.textContent = Number(ui.backbeat.value).toFixed(2);
    ui.downV.textContent = Number(ui.downbeat.value).toFixed(2);
    ui.humV.textContent = Number(ui.humanize.value).toFixed(2);
  }
  ["input","change"].forEach(ev=>{
    [ui.genMode,ui.stage,ui.style,ui.feel,ui.seed,ui.grid,ui.bpm,ui.leadIn,ui.offset,ui.minGap,ui.threshold,ui.lowW,ui.backbeat,ui.downbeat,ui.humanize]
      .forEach(el=>el.addEventListener(ev, upd));
  });
  upd();

  function extLower(name){
    const m = String(name||"").toLowerCase().match(/\.([a-z0-9]+)$/);
    return m ? m[1] : "";
  }
  function isProbablyAudioFile(file){
    const t = String(file?.type || "").toLowerCase();
    if (t.startsWith("audio/")) return true;
    if (t === "video/mp4") return true;
    const e = extLower(file?.name);
    return ["mp3","m4a","aac","wav","caf","aiff","mp4","mov"].includes(e);
  }

  // ----------------------------
  // Seeded RNG
  // ----------------------------
  function mulberry32(seed){
    let a = (seed>>>0) || 1;
    return function(){
      a |= 0; a = a + 0x6D2B79F5 | 0;
      let t = Math.imul(a ^ a >>> 15, 1 | a);
      t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
  }

  // ----------------------------
  // Audio: single-clock backbone (iOS safe)
  // ----------------------------
  const AC = window.AudioContext || window.webkitAudioContext;
  let audioCtx = null;
  let audioSrc = null;

  function ensureAudioCtx(){
    if (!audioCtx) audioCtx = new AC();
    return audioCtx;
  }

  async function unlockAudio(tag){
    const ctx = ensureAudioCtx();
    try{ await ctx.resume(); }catch{}
    // iOS対策: 無音を一瞬鳴らして unlock をより確実に
    try{
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      g.gain.value = 0.0001;
      o.connect(g).connect(ctx.destination);
      o.start();
      o.stop(ctx.currentTime + 0.01);
    }catch{}
  }

  async function decodeFileToAudioBuffer(file){
    const ctx = ensureAudioCtx();
    await unlockAudio("decode");
    const ab = await file.arrayBuffer();
    try{
      return await ctx.decodeAudioData(ab);
    }catch(e){
      throw new Error("decodeAudioData failed. iOSは Filesアプリ経由の mp3/m4a 推奨。別ファイルで再試行して。");
    }
  }

  function stopAudio(){
    try{ audioSrc?.stop?.(); }catch{}
    audioSrc = null;
  }

  // ----------------------------
  // Preview metronome
  // ----------------------------
  let previewTimer = null;
  function stopPreview(){
    if(previewTimer){
      clearInterval(previewTimer);
      previewTimer = null;
    }
    if(state.mode === MODE.PREVIEW) setMode(MODE.LOADED);
    ui.previewPlay.textContent = "Preview Play (metronome)";
  }

  function playClick(){
    const ctx = ensureAudioCtx();
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.type = "square";
    o.frequency.value = 880;
    g.gain.value = 0.05;
    o.connect(g).connect(ctx.destination);
    o.start();
    o.stop(ctx.currentTime + 0.03);
  }

  // ----------------------------
  // Onset detection (spectral flux lightweight)
  // ----------------------------
  function hanning(n, N) { return 0.5 - 0.5 * Math.cos((2 * Math.PI * n) / Math.max(1, N - 1)); }

  function dftMag(frame, bins) {
    const N = frame.length, out = new Float32Array(bins);
    for (let k = 0; k < bins; k++) {
      let re = 0, im = 0, w = 2 * Math.PI * k / N;
      for (let n = 0; n < N; n++) {
        const x = frame[n];
        re += x * Math.cos(w * n);
        im -= x * Math.sin(w * n);
      }
      out[k] = Math.sqrt(re * re + im * im);
    }
    return out;
  }

  function detectOnsets(chData, sr, opt) {
    const N = 1024, hop = 512, bins = 32;
    const frames = Math.max(0, Math.floor((chData.length - N) / hop));
    const env = new Float32Array(frames);
    let prev = new Float32Array(bins);

    for (let f = 0; f < frames; f++) {
      const start = f * hop;
      const frame = new Float32Array(N);
      for (let i = 0; i < N; i++) frame[i] = (chData[start + i] || 0) * hanning(i, N);
      const mag = dftMag(frame, bins);

      let flux = 0;
      for (let k = 0; k < bins; k++) {
        const d = mag[k] - prev[k];
        if (d > 0) flux += d * (k < 8 ? opt.lowW : 1);
      }
      env[f] = flux;
      prev = mag;
    }

    const mean = env.reduce((a,b)=>a+b,0) / Math.max(1, env.length);
    const onset = [];
    for (let i = 2; i < env.length - 2; i++) {
      if (env[i] > env[i-1] && env[i] > env[i+1] && env[i] > mean * opt.threshold) {
        onset.push(i * hop / sr);
      }
    }
    return { env, onset, hop, sr, mean };
  }

  function estimateBpm(envPack) {
    const env = envPack.env;
    if (!env.length) return 120;
    const fps = envPack.sr / envPack.hop;

    let bestLag = 0, best = -1;
    const minLag = Math.floor(fps * 60 / 190);
    const maxLag = Math.floor(fps * 60 / 70);

    for (let lag = minLag; lag <= maxLag; lag++) {
      let sum = 0;
      for (let i = lag; i < env.length; i++) sum += env[i] * env[i - lag];
      if (sum > best) { best = sum; bestLag = lag; }
    }
    if (!bestLag) return 120;

    let bpm = 60 * fps / bestLag;
    while (bpm < 80) bpm *= 2;
    while (bpm > 180) bpm /= 2;
    return Math.max(70, Math.min(190, bpm));
  }

  // ----------------------------
  // PRO Auto
  // ----------------------------
  function buildGridScores(envPack, bpm, grid){
    const fps = envPack.sr / envPack.hop;
    const step = 60 / bpm / (grid / 4);
    const dur = envPack.env.length / fps;

    const scores = [];
    for(let t=0; t<dur; t+=step){
      const idx = Math.max(0, Math.min(envPack.env.length-1, Math.round(t*fps)));
      scores.push({ t, s: envPack.env[idx] || 0 });
    }

    let mx = 0;
    for(const p of scores) if(p.s > mx) mx = p.s;
    mx = mx || 1;
    for(const p of scores) p.s = p.s / mx;

    for(let i=1;i<scores.length-1;i++){
      scores[i].s = (scores[i-1].s + scores[i].s + scores[i+1].s)/3;
    }

    return { step, dur, scores };
  }

  function pickNotesRhythmic(gridPack, bpm, grid, opt){
    const { step, scores } = gridPack;
    const beat = 60 / bpm;
    const bar = beat * 4;
    const minGap = Math.max(0.001, (opt.minGapMs||95)/1000);

    const downBias = opt.downBias ?? 0.18;
    const backBias = opt.backBias ?? 0.14;

    const notes = [];
    let lastT = -1e9;

    const peakThresh = opt.peakThresh ?? 0.78;

    const canPlace = (t, strong=false) => {
      const dt = t - lastT;
      if(!strong && dt < minGap) return false;
      if(!strong && dt < step*0.95) return false;
      return true;
    };

    const basePerBar = opt.basePerBar ?? 3;
    const addPerBar  = opt.addPerBar  ?? 6;
    const maxPerBar  = opt.maxPerBar  ?? 10;
    const minPerBar  = opt.minPerBar  ?? 2;

    const tEnd = scores.length ? scores[scores.length-1].t : 0;

    for(let barStart=0; barStart < tEnd; barStart += bar){
      const barEnd = barStart + bar;

      const slice = [];
      for(const p of scores){
        if(p.t >= barStart && p.t < barEnd) slice.push(p);
      }
      if(!slice.length) continue;

      const energy = slice.reduce((a,b)=>a+b.s,0)/slice.length;
      let target = Math.round(basePerBar + energy*addPerBar);
      target = Math.max(minPerBar, Math.min(maxPerBar, target));

      for(const p of slice){
        const beatPos = (p.t - barStart)/beat;
        const sub = beatPos % 1;
        const bi = Math.floor(beatPos + 1e-6);

        let w = 1.0;
        if(bi === 0 || bi === 2) w += downBias;
        if(grid >= 8 && Math.abs(sub - 0.5) < 0.12) w += backBias;
        if(grid >= 16 && (Math.abs(sub-0.25)<0.10 || Math.abs(sub-0.75)<0.10)) w += 0.06;

        p._score = p.s * w;
      }

      slice.sort((a,b)=>b._score - a._score);

      let picked = 0;
      for(const p of slice){
        if(picked >= target) break;
        if(p.t < 0.06) continue;

        const strong = p.s >= peakThresh;
        if(!canPlace(p.t, strong)) continue;

        notes.push(+p.t.toFixed(3));
        lastT = p.t;
        picked++;
      }

      if(target >= 9){
        lastT = Math.max(lastT, barEnd - step*0.5);
      }
    }

    notes.sort((a,b)=>a-b);

    const out=[];
    let prev=-1e9;
    for(const t of notes){
      if(Math.abs(t-prev) > 1e-3) out.push(t);
      prev=t;
    }
    return out;
  }

  // ----------------------------
  // GOD Auto (Stage/Feel/Style + Chorus + Density Curve)
  // ----------------------------
  function mapFeel(feel01, stage, style){
    let minGapMs = 130 - feel01*60;       // 130..70
    let chorusBoost = 1.25 + feel01*0.65; // 1.25..1.90
    let sixteen = 0.03 + feel01*0.22;     // 0.03..0.25
    let backBias = 0.06 + feel01*0.22;    // 0.06..0.28
    let downBias = 0.10 + feel01*0.18;    // 0.10..0.28

    if(stage === "calm"){
      minGapMs += 18; chorusBoost -= 0.18; sixteen -= 0.04;
    }else if(stage === "chaos"){
      minGapMs -= 10; chorusBoost += 0.10; sixteen += 0.06;
    }

    if(style === "stable"){
      downBias += 0.08; backBias -= 0.04; sixteen -= 0.04;
    }else if(style === "groove"){
      backBias += 0.08; sixteen += 0.02;
    }else if(style === "technical"){
      sixteen += 0.08; minGapMs -= 6;
    }

    minGapMs = Math.max(55, Math.min(160, minGapMs));
    sixteen = Math.max(0, Math.min(0.35, sixteen));
    backBias = Math.max(0, Math.min(0.35, backBias));
    downBias = Math.max(0, Math.min(0.35, downBias));

    return { minGapMs, chorusBoost, sixteen, backBias, downBias };
  }

  function smoothArray(a, win){
    const out = new Float32Array(a.length);
    const w = Math.max(1, win|0);
    for(let i=0;i<a.length;i++){
      let s=0,c=0;
      for(let k=-w;k<=w;k++){
        const j=i+k;
        if(j<0||j>=a.length) continue;
        s += a[j]; c++;
      }
      out[i] = c? (s/c) : a[i];
    }
    return out;
  }

  // chorus detection: energy over smoothed baseline (time-aware thresholds)
  function detectChorusMask(envPack){
    const env = envPack.env;
    if(env.length < 32) return { mask: new Uint8Array(env.length), ratio:0, segments:[] };

    let mx = 0;
    for(let i=0;i<env.length;i++) if(env[i]>mx) mx=env[i];
    mx = mx || 1;

    const norm = new Float32Array(env.length);
    for(let i=0;i<env.length;i++) norm[i]=env[i]/mx;

    const slow = smoothArray(norm, 24);
    const fast = smoothArray(norm, 6);

    const score = new Float32Array(env.length);
    for(let i=0;i<env.length;i++){
      score[i] = fast[i] / (slow[i] + 1e-4);
    }

    let mean=0;
    for(let i=0;i<score.length;i++) mean += score[i];
    mean /= score.length;

    let v=0;
    for(let i=0;i<score.length;i++){ const d=score[i]-mean; v+=d*d; }
    const std = Math.sqrt(v/score.length);
    const thr = mean + std*0.65;

    const mask = new Uint8Array(env.length);
    for(let i=0;i<score.length;i++){
      mask[i] = (score[i] >= thr) ? 1 : 0;
    }

    // 時間換算して minLen / gapMax を決める（曲によりfpsが変わっても破綻しない）
    const fps = envPack.sr / envPack.hop;
    const minSec = 3.0;         // 3秒以上をサビ候補
    const gapSec = 1.0;         // 1秒未満の途切れは埋める
    const minLen = Math.max(8, Math.round(minSec * fps));
    const gapMax = Math.max(4, Math.round(gapSec * fps));

    // remove tiny bursts
    let run=0;
    for(let i=0;i<=mask.length;i++){
      if(i<mask.length && mask[i]) run++;
      else{
        if(run>0 && run<minLen){
          for(let j=i-run;j<i;j++) mask[j]=0;
        }
        run=0;
      }
    }
    // fill tiny gaps
    let gap=0;
    for(let i=0;i<=mask.length;i++){
      if(i<mask.length && !mask[i]) gap++;
      else{
        if(gap>0 && gap<=gapMax){
          for(let j=i-gap;j<i;j++) mask[j]=1;
        }
        gap=0;
      }
    }

    const seg=[];
    let s=-1;
    for(let i=0;i<=mask.length;i++){
      const v = (i<mask.length)?mask[i]:0;
      if(v && s<0) s=i;
      if(!v && s>=0){
        seg.push([s, i-1]);
        s=-1;
      }
    }

    let ones=0;
    for(let i=0;i<mask.length;i++) if(mask[i]) ones++;
    const ratio = ones / Math.max(1, mask.length);

    return { mask, ratio, segments: seg, fps };
  }

  function pickNotesGod(gridPack, bpm, grid, envPack, godOpt, rng){
    const { step, scores } = gridPack;
    const beat = 60 / bpm;
    const bar  = beat * 4;

    const minGap = Math.max(0.001, (godOpt.minGapMs||95)/1000);

    const notes = [];
    let lastT = -1e9;

    const canPlace = (t, strong=false) => {
      const dt = t - lastT;
      if(!strong && dt < minGap) return false;
      if(!strong && dt < step*0.92) return false;
      return true;
    };

    const chorus = detectChorusMask(envPack);
    ui.chorusInfo.value = `ratio ${(chorus.ratio*100).toFixed(0)}% / seg ${chorus.segments.length}`;

    const stage = ui.stage.value;
    let basePerBar = 3, addPerBar = 7, maxPerBar = 12, minPerBar = 2;
    if(stage==="calm"){ basePerBar=2; addPerBar=5; maxPerBar=8;  minPerBar=1; }
    if(stage==="chaos"){basePerBar=4; addPerBar=9; maxPerBar=16; minPerBar=3; }

    const style = ui.style.value;
    let restChance = 0.12;
    let techChance = godOpt.sixteen;
    if(style==="stable"){ restChance = 0.18; techChance *= 0.55; }
    if(style==="groove"){ restChance = 0.10; techChance *= 0.95; }
    if(style==="technical"){ restChance = 0.08; techChance *= 1.20; }

    const tEnd = scores.length ? scores[scores.length-1].t : 0;

    const fps = envPack.sr / envPack.hop;

    for(let barStart=0; barStart < tEnd; barStart += bar){
      const barEnd = barStart + bar;

      const slice = [];
      for(const p of scores){
        if(p.t >= barStart && p.t < barEnd) slice.push(p);
      }
      if(!slice.length) continue;

      const energy = slice.reduce((a,b)=>a+b.s,0)/slice.length;

      const idxA = Math.max(0, Math.min(envPack.env.length-1, Math.floor(barStart*fps)));
      const idxB = Math.max(0, Math.min(envPack.env.length-1, Math.floor(barEnd*fps)));
      let chorusHit = 0, total = Math.max(1, idxB-idxA);
      for(let i=idxA;i<idxB;i++) chorusHit += chorus.mask[i] ? 1 : 0;
      const isChorusBar = (chorusHit/total) > 0.55;

      let target = Math.round(basePerBar + energy*addPerBar);
      target = Math.max(minPerBar, Math.min(maxPerBar, target));
      if(isChorusBar) target = Math.round(target * godOpt.chorusBoost);

      if(rng() < restChance){
        target = Math.max(minPerBar, Math.round(target * 0.72));
        lastT = Math.max(lastT, barStart + beat*0.5);
      }

      const downBias = godOpt.downBias;
      const backBias = godOpt.backBias;

      for(const p of slice){
        const beatPos = (p.t - barStart)/beat;
        const sub = beatPos % 1;
        const bi = Math.floor(beatPos + 1e-6);

        let w = 1.0;
        if(bi === 0 || bi === 2) w += downBias;
        if(grid >= 8 && Math.abs(sub - 0.5) < 0.13) w += backBias;
        if(grid >= 16 && (Math.abs(sub-0.25)<0.11 || Math.abs(sub-0.75)<0.11)) w += techChance;
        if(isChorusBar) w += 0.06;

        p._score = p.s * w;
      }

      slice.sort((a,b)=>b._score - a._score);

      let picked = 0;
      for(const p of slice){
        if(picked >= target) break;
        if(p.t < 0.06) continue;

        const strong = p.s >= 0.80;
        if(!canPlace(p.t, strong)) continue;

        notes.push(+p.t.toFixed(3));
        lastT = p.t;
        picked++;
      }

      if(target >= 10){
        lastT = Math.max(lastT, barEnd - step*0.6);
      }
    }

    notes.sort((a,b)=>a-b);

    const out=[];
    let prev=-1e9;
    for(const t of notes){
      if(Math.abs(t-prev) > 1e-3) out.push(t);
      prev=t;
    }
    return out;
  }

  // ----------------------------
  // Timing postprocess
  // ----------------------------
  function humanizeTimes(times, bpm, amount01){
    const beat = 60 / bpm;
    const a = Math.max(0, Math.min(1, amount01||0));
    const maxMs = 14 * a;
    const pushMs = 8 * a;
    const pullMs = 6 * a;

    const out = times.map((t,i)=>{
      const phase = (t % beat) / beat;
      let dt = 0;

      if(phase < 0.08 || phase > 0.92) dt += (pullMs/1000);
      if(Math.abs(phase - 0.5) < 0.08) dt -= (pushMs/1000);

      const r = (Math.sin((i+1)*999.17) * 0.5 + 0.5);
      const jitter = ((r*2-1) * (maxMs/1000)) * 0.35;
      dt += jitter;

      return +(t + dt).toFixed(3);
    });

    out.sort((a,b)=>a-b);
    return out;
  }

  function quantizeTimes(times, bpm, grid){
    if(!grid || grid<=0) return times.slice();
    const step = 60 / bpm / (grid/4);
    return times.map(t => +((Math.round(t/step)*step).toFixed(3)));
  }

  function applyMinGap(times, minGapMs){
    const minGap = (Number(minGapMs)||0)/1000;
    const out=[];
    let last=-1e9;
    for(const t of times){
      if(t - last < minGap) continue;
      out.push(t);
      last=t;
    }
    return out;
  }

  function addLeadAndOffset(times, leadInSec, offsetMs){
    const off = (Number(offsetMs)||0)/1000;
    const lead = Math.max(0, Number(leadInSec)||0);
    return times.map(t => +(t + lead + off).toFixed(3)).filter(t => t >= 0.01);
  }

  function finalizeTimes(times, bpm){
    const grid = Number(ui.grid.value)||0;
    let t = times.slice().filter(v => Number.isFinite(v) && v>=0);

    // 1) UI MinGap
    t = applyMinGap(t, Number(ui.minGap.value));
    // 2) Humanize
    t = humanizeTimes(t, bpm, Number(ui.humanize.value));
    // 3) Quantize (optional)
    t = quantizeTimes(t, bpm, grid);
    // 4) MinGap again
    t = applyMinGap(t, Number(ui.minGap.value));
    // 5) Lead+Offset
    t = addLeadAndOffset(t, Number(ui.leadIn.value), Number(ui.offset.value));

    t.sort((a,b)=>a-b);
    const out=[];
    let prev=-1e9;
    for(const x of t){
      if(Math.abs(x-prev) > 1e-3) out.push(x);
      prev=x;
    }
    return out;
  }

  // ----------------------------
  // Chart helpers
  // ----------------------------
  function chartObjFromTimes(times, bpm, titleSuffix=""){
    const base = (state.fileName||"Song").replace(/\.[^.]+$/, "");
    return {
      meta: { title: (base + titleSuffix), bpm: +Number(bpm).toFixed(2) },
      offset: 0,
      scroll: { approach: 1.25 },
      notes: times.map(t => ({ t:+t.toFixed(3), lane:1, type:"tap" }))
    };
  }

  function autoLevelFromChart(times, duration){
    const nps = times.length / Math.max(1e-3, duration);
    let lv = Math.round(1 + nps * 2.2);
    lv = Math.max(1, Math.min(10, lv));
    return { lv, nps: +nps.toFixed(2) };
  }

  function showPayload(payload){
    state.lastPayload = payload;
    ui.preview.textContent = JSON.stringify(payload, null, 2).slice(0, 20000);
    refreshButtons();
  }

  function mergeTimes(aTimes, bTimes){
    const all = [...aTimes, ...bTimes].sort((x,y)=>x-y);
    const out=[];
    let last=-1e9;
    const minGap = (Number(ui.minGap.value)||0)/1000;
    for(const t of all){
      if(t - last < minGap) continue;
      out.push(t);
      last = t;
    }
    return out;
  }

  // GOD difficulty thinning: keep strong beats / chorus priority
  function buildGodBundle(baseTimes, bpm){
    const titleBase = (state.fileName||"Song").replace(/\.[^.]+$/, "");
    const meta = {
      title: titleBase,
      bpm: +Number(bpm).toFixed(2),
      stage: ui.stage.value,
      style: ui.style.value,
      feel: Number(ui.feel.value),
      seed: Number(ui.seed.value)||1
    };

    const hard = baseTimes.slice();
    const beat = 60 / bpm;

    const isStrong = (t) => {
      const phase = (t % beat) / beat;
      // 0 (強拍) / 0.5 (裏) 近いなら強い扱い
      return (phase < 0.06 || phase > 0.94 || Math.abs(phase-0.5) < 0.06);
    };

    const rng = mulberry32(Number(ui.seed.value)||1);

    const normal = [];
    for(let i=0;i<hard.length;i++){
      const t = hard[i];
      const keepStrong = isStrong(t);
      const keep = keepStrong ? (rng() < 0.92) : (rng() < 0.70);
      if(keep) normal.push(t);
    }

    const easy = [];
    for(let i=0;i<hard.length;i++){
      const t = hard[i];
      const keepStrong = isStrong(t);
      const keep = keepStrong ? (i%2===0) : (i%3===0);
      if(keep) easy.push(t);
    }

    const out = {
      meta,
      easy: chartObjFromTimes(easy, bpm, " [EASY]"),
      normal: chartObjFromTimes(normal, bpm, " [NORMAL]"),
      hard: chartObjFromTimes(hard, bpm, " [HARD]"),
      bundle: {
        meta,
        charts: {
          easy: chartObjFromTimes(easy, bpm, " [EASY]"),
          normal: chartObjFromTimes(normal, bpm, " [NORMAL]"),
          hard: chartObjFromTimes(hard, bpm, " [HARD]")
        }
      }
    };
    return out;
  }

  // ----------------------------
  // REC: tap capture (single clock)
  // ----------------------------
  let rec = {
    recording:false,
    startTime:0,
    taps:[],
    handler:null,
  };

  function setRecCount(){
    ui.meterC.textContent = `rec taps: ${rec.taps.length}`;
  }

  function isUiElement(el){
    if(!el) return false;
    return !!el.closest("#uiRoot"); // UI内クリックは除外したい
  }

  async function startREC(){
    if(!state.audioBuf) throw new Error("audio not loaded");
    await unlockAudio("rec");

    stopPreview();
    stopAudio();

    const ctx = ensureAudioCtx();
    const src = ctx.createBufferSource();
    src.buffer = state.audioBuf;
    src.connect(ctx.destination);

    rec.taps = [];
    rec.recording = true;
    rec.startTime = ctx.currentTime;
    setRecCount();

    // REC中はUIボタンを誤爆しやすいので、UI内は除外
    rec.handler = (ev)=>{
      if(!rec.recording) return;
      if(isUiElement(ev.target)) return;
      const t = ctx.currentTime - rec.startTime;
      if(t < 0) return;
      rec.taps.push(+t.toFixed(4));
      setRecCount();
    };

    // capture で先に拾って、UI内は弾く
    window.addEventListener("pointerdown", rec.handler, { passive:true, capture:true });

    src.onended = ()=>{
      if(rec.recording) stopREC();
    };

    src.start();
    audioSrc = src;

    setMode(MODE.REC);
    setStatus("REC started. 画面の“UI以外”を曲に合わせてタップしてOK（誤爆防止）", true);
  }

  function stopREC(){
    rec.recording = false;
    try{ window.removeEventListener("pointerdown", rec.handler, { capture:true }); }catch{}
    try{ window.removeEventListener("pointerdown", rec.handler, true); }catch{}
    rec.handler = null;

    stopAudio();

    setMode(MODE.LOADED);
    setStatus(`REC stopped. taps=${rec.taps.length}`, true);
    setRecCount();
  }

  function clearREC(){
    if(rec.recording) return;
    rec.taps = [];
    setRecCount();
    state.recChart = null;
    state.mergedChart = null;
    setStatus("REC cleared.", true);
    refreshButtons();
  }

  // ----------------------------
  // Actions
  // ----------------------------
  function hardResetCharts(){
    state.envPack = null;
    state.bpm = 0;
    state.autoChart = null;
    state.recChart = null;
    state.mergedChart = null;
    state.god = null;
    state.lastPayload = null;

    ui.preview.textContent = "{}";
    ui.download.disabled = true;
    ui.level.value = "--";
    ui.chorusInfo.value = "--";
    refreshButtons();
  }

  ui.load.addEventListener("click", async () => {
    ui.load.disabled = true;
    setStatus("Loading...", true);

    // 事故防止：全部止める
    stopPreview();
    stopAudio();
    if(rec.recording) stopREC();

    try{
      const file = ui.audioFile.files?.[0];
      if(!file) throw new Error("select audio file");
      if(!isProbablyAudioFile(file)) throw new Error(`not audio: ${file.name} type=${file.type||"(empty)"}`);

      setStatus(`Decoding... ${file.name} (type=${file.type || "empty"})`, true);

      const buf = await decodeFileToAudioBuffer(file);
      state.audioBuf = buf;
      state.fileName = file.name;

      ui.meterA.textContent = `audio: ${Math.max(0, buf.duration).toFixed(2)}s`;

      hardResetCharts();
      rec.taps = [];
      setRecCount();

      setMode(MODE.LOADED);
      setStatus(`OK: decoded. duration=${buf.duration.toFixed(2)}s`, true);

    }catch(e){
      setMode(MODE.IDLE);
      setStatus("Error: " + (e?.message || e), false);
    }finally{
      ui.load.disabled = false;
      refreshButtons();
    }
  });

  ui.auto.addEventListener("click", async () => {
    ui.auto.disabled = true;
    setStatus("Analyzing (spectral flux) ...", true);

    try{
      if(!state.audioBuf) throw new Error("audio not loaded");
      await unlockAudio("auto");

      stopPreview(); // preview中にauto事故防止

      const data = state.audioBuf.getChannelData(0);
      const opt = { threshold: Number(ui.threshold.value), lowW: Number(ui.lowW.value) };
      const envPack = detectOnsets(data, state.audioBuf.sampleRate, opt);
      state.envPack = envPack;

      let bpm = Number(ui.bpm.value)||0;
      if(!(bpm>0)) bpm = estimateBpm(envPack);
      state.bpm = bpm;
      ui.bpm.value = bpm.toFixed(2);
      ui.meterB.textContent = `bpm: ${bpm.toFixed(2)}`;

      const genGrid = Math.max(8, Number(ui.grid.value)||8);
      const pack = buildGridScores(envPack, bpm, genGrid);

      if(ui.genMode.value === "pro"){
        const timesRaw = pickNotesRhythmic(pack, bpm, genGrid, {
          minGapMs: Number(ui.minGap.value),
          basePerBar: 3,
          addPerBar: 6,
          minPerBar: 2,
          maxPerBar: 10,
          downBias: Number(ui.downbeat.value),
          backBias: Number(ui.backbeat.value),
          peakThresh: 0.78,
        });

        const times = finalizeTimes(timesRaw, bpm);
        const chart = chartObjFromTimes(times, bpm);

        state.autoChart = chart;
        state.god = null;
        ui.chorusInfo.value = "--";

        const { lv, nps } = autoLevelFromChart(times, state.audioBuf.duration);
        ui.level.value = `Lv.${lv} (nps ${nps})`;

        showPayload(chart);
        setStatus(`PRO Auto OK: notes=${chart.notes.length}, bpm=${bpm.toFixed(2)}`, true);

      }else{
        const rng = mulberry32(Number(ui.seed.value)||1);
        const feel01 = Math.max(0, Math.min(1, Number(ui.feel.value)/100));
        const god = mapFeel(feel01, ui.stage.value, ui.style.value);

        const timesRaw = pickNotesGod(pack, bpm, genGrid, envPack, god, rng);

        let times = applyMinGap(timesRaw, god.minGapMs);
        times = finalizeTimes(times, bpm);

        state.god = buildGodBundle(times, bpm);

        // default: HARD
        showPayload(state.god.hard);

        const { lv, nps } = autoLevelFromChart(times, state.audioBuf.duration);
        ui.level.value = `Lv.${lv} (nps ${nps})`;

        setStatus(`GOD Auto OK: HARD notes=${state.god.hard.notes.length}, bpm=${bpm.toFixed(2)} / stage=${ui.stage.value} / feel=${ui.feel.value}`, true);
      }

    }catch(e){
      setStatus("Error: " + (e?.message || e), false);
    }finally{
      ui.auto.disabled = false;
      refreshButtons();
    }
  });

  ui.recStart.addEventListener("click", async () => {
    try{
      await startREC();
    }catch(e){
      setStatus("Error: " + (e?.message || e), false);
      setMode(state.audioBuf ? MODE.LOADED : MODE.IDLE);
      refreshButtons();
    }
  });

  ui.recStop.addEventListener("click", () => stopREC());
  ui.clearRec.addEventListener("click", () => clearREC());

  ui.buildFromRec.addEventListener("click", async () => {
    ui.buildFromRec.disabled = true;
    try{
      if(!state.audioBuf) throw new Error("audio not loaded");
      if(!rec.taps.length) throw new Error("REC taps is empty");

      let bpm = Number(ui.bpm.value)||0;
      if(!(bpm>0)){
        bpm = state.bpm>0 ? state.bpm : 145;
        ui.bpm.value = bpm.toFixed(2);
      }
      state.bpm = bpm;
      ui.meterB.textContent = `bpm: ${bpm.toFixed(2)}`;

      const times = finalizeTimes(rec.taps, bpm);
      const chart = chartObjFromTimes(times, bpm, " [REC]");
      state.recChart = chart;

      const { lv, nps } = autoLevelFromChart(times, state.audioBuf.duration);
      ui.level.value = `Lv.${lv} (nps ${nps})`;

      showPayload(chart);
      setStatus(`REC chart OK: notes=${chart.notes.length}`, true);

    }catch(e){
      setStatus("Error: " + (e?.message || e), false);
    }finally{
      refreshButtons();
    }
  });

  ui.merge.addEventListener("click", async () => {
    ui.merge.disabled = true;
    try{
      if(!state.autoChart || !state.recChart) throw new Error("need both Auto(PRO) and REC charts");
      const bpm = state.bpm || Number(ui.bpm.value) || 145;

      const a = state.autoChart.notes.map(n=>n.t);
      const b = state.recChart.notes.map(n=>n.t);

      const mergedTimes = mergeTimes(a,b);
      const chart = chartObjFromTimes(mergedTimes, bpm, " [MERGED]");
      state.mergedChart = chart;

      const { lv, nps } = autoLevelFromChart(mergedTimes, state.audioBuf.duration);
      ui.level.value = `Lv.${lv} (nps ${nps})`;

      showPayload(chart);
      setStatus(`Merged OK: notes=${chart.notes.length}`, true);

    }catch(e){
      setStatus("Error: " + (e?.message || e), false);
    }finally{
      refreshButtons();
    }
  });

  ui.download.addEventListener("click", () => {
    let payload = null;
    let name = "chart.json";

    if(ui.genMode.value === "god" && state.god){
      const diff = ui.dlDiff.value;
      if(diff === "easy"){ payload = state.god.easy; name="chart_easy.json"; }
      else if(diff === "normal"){ payload = state.god.normal; name="chart_normal.json"; }
      else if(diff === "hard"){ payload = state.god.hard; name="chart_hard.json"; }
      else if(diff === "bundle"){ payload = state.god.bundle; name="chart_bundle.json"; }
      else { payload = state.lastPayload; name="chart.json"; }
    }else{
      payload = state.lastPayload;
      name = "chart.json";
    }

    if(!payload) return;

    const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
    const a = document.createElement("a");
    const url = URL.createObjectURL(blob);
    a.href = url;
    a.download = name;
    a.click();
    setTimeout(()=>URL.revokeObjectURL(url), 800);
  });

  ui.previewPlay.addEventListener("click", async () => {
    if(!state.audioBuf){
      setStatus("Load audio first.", false);
      return;
    }
    await unlockAudio("preview");

    if(previewTimer){
      stopPreview();
      setStatus("Preview stopped.", true);
      refreshButtons();
      return;
    }

    if(rec.recording){
      setStatus("Stop REC first.", false);
      return;
    }

    let bpm = Number(ui.bpm.value)||0;
    if(!(bpm>0)){
      bpm = state.bpm || 145;
      ui.bpm.value = bpm.toFixed(2);
      ui.meterB.textContent = `bpm: ${bpm.toFixed(2)}`;
    }
    const beatMs = (60 / bpm) * 1000;

    setMode(MODE.PREVIEW);
    setStatus("Preview metronome started. (tap feel check)", true);
    ui.previewPlay.textContent = "Preview Stop";

    playClick();
    previewTimer = setInterval(()=>playClick(), beatMs);
    refreshButtons();
  });

  // 画面が隠れたら事故防止で全部止める（iOSで重要）
  document.addEventListener("visibilitychange", () => {
    if(document.hidden){
      stopPreview();
      if(rec.recording) stopREC();
      stopAudio();
      refreshButtons();
    }
  });

  // init
  setRecCount();
  setMode(MODE.IDLE);
  refreshButtons();
})();
</script>

</body>
</html>
