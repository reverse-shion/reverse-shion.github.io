<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>DI Chart Maker</title>
  <style>
    body{margin:0;background:#0b0f18;color:#e8eeff;font:14px/1.4 system-ui;padding:12px}
    .card{background:#111a2a;border:1px solid #2a3754;border-radius:10px;padding:10px;margin-bottom:10px}
    label{display:block;font-size:12px;color:#9eb0d8;margin:8px 0 4px}
    input,select,button,textarea{width:100%;box-sizing:border-box;border-radius:8px;border:1px solid #33466d;background:#0e1626;color:#eef3ff;padding:8px}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:8px}
    button{background:#345dff;border-color:#4c72ff;font-weight:700}
    button:disabled{opacity:.5}
    pre{max-height:220px;overflow:auto;background:#0a1220;border:1px solid #273657;padding:8px;border-radius:8px;white-space:pre-wrap}
    .hint{font-size:12px;color:#b8c7ef;opacity:.9;margin-top:6px}
    .ok{color:#7cffc0}
    .ng{color:#ff7a7a}
  </style>
</head>
<body>
  <div class="card">
    <label>Audio file</label>
    <!-- ✅ Dropbox/iOSで“候補が出ない”事故を避けるため accept を緩める -->
    <!-- それでも拡張子は列挙しておく（Filesでは効く） -->
    <input id="audioFile" type="file"
      accept=".mp3,.m4a,.aac,.wav,.caf,.aiff,.mp4,.mov,audio/*,video/*" />

    <div class="hint">
      iOS/Dropboxでmp3が出ない時は、まずこの入力で<strong>mp3/m4a</strong>を選んでOK。<br/>
      ※Dropboxは type が空になることがあるので、拡張子で判定します。
    </div>

    <div class="row" style="margin-top:8px">
      <div><label>Grid</label>
        <select id="grid">
          <option value="4">1/4</option>
          <option value="8" selected>1/8</option>
          <option value="16">1/16</option>
        </select>
      </div>
      <div><label>BPM (0=auto)</label>
        <input id="bpm" type="number" min="0" step="0.1" value="0" />
      </div>
    </div>

    <label>Min Gap (ms): <span id="minGapV">110</span></label>
    <input id="minGap" type="range" min="40" max="260" value="110" />

    <label>Sensitivity: <span id="thV">1.6</span></label>
    <input id="threshold" type="range" min="0.8" max="3.5" step="0.05" value="1.6" />

    <label>Low-frequency Weight: <span id="lowWV">1.2</span></label>
    <input id="lowW" type="range" min="0.2" max="3" step="0.05" value="1.2" />

    <div class="row" style="margin-top:8px">
      <button id="analyze">Analyze</button>
      <button id="download" disabled>Download chart.json</button>
    </div>

    <div id="status" class="hint"></div>
  </div>

  <div class="card">
    <strong>Preview JSON</strong>
    <pre id="preview">{}</pre>
  </div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);
  const ui = {
    audioFile: $("audioFile"),
    grid: $("grid"),
    bpm: $("bpm"),
    minGap: $("minGap"),
    threshold: $("threshold"),
    lowW: $("lowW"),
    minGapV: $("minGapV"),
    thV: $("thV"),
    lowWV: $("lowWV"),
    analyze: $("analyze"),
    download: $("download"),
    status: $("status"),
    preview: $("preview"),
  };

  let chart = null;

  const upd = () => {
    ui.minGapV.textContent = ui.minGap.value;
    ui.thV.textContent = ui.threshold.value;
    ui.lowWV.textContent = ui.lowW.value;
  };
  ["input","change"].forEach(ev => {
    ui.minGap.addEventListener(ev, upd);
    ui.threshold.addEventListener(ev, upd);
    ui.lowW.addEventListener(ev, upd);
  });
  upd();

  function setStatus(msg, ok=false){
    ui.status.innerHTML = ok ? `<span class="ok">${msg}</span>` : `<span class="ng">${msg}</span>`;
  }

  function extLower(name){
    const m = String(name||"").toLowerCase().match(/\.([a-z0-9]+)$/);
    return m ? m[1] : "";
  }

  function isProbablyAudioFile(file){
    // Dropboxだと file.type が空のことがある → 拡張子で判定
    const t = String(file?.type || "");
    if (t.startsWith("audio/")) return true;
    const e = extLower(file?.name);
    return ["mp3","m4a","aac","wav","caf","aiff","mp4","mov"].includes(e);
  }

  // -----------------------------
  // Onset detection (lightweight)
  // -----------------------------
  function hanning(n, N) { return 0.5 - 0.5 * Math.cos((2 * Math.PI * n) / Math.max(1, N - 1)); }

  function dftMag(frame, bins) {
    const N = frame.length, out = new Float32Array(bins);
    for (let k = 0; k < bins; k++) {
      let re = 0, im = 0, w = 2 * Math.PI * k / N;
      for (let n = 0; n < N; n++) {
        const x = frame[n];
        re += x * Math.cos(w * n);
        im -= x * Math.sin(w * n);
      }
      out[k] = Math.sqrt(re * re + im * im);
    }
    return out;
  }

  function detectOnsets(chData, sr, opt) {
    const N = 1024, hop = 512, bins = 32;
    const frames = Math.max(0, Math.floor((chData.length - N) / hop));
    const env = new Float32Array(frames);
    let prev = new Float32Array(bins);

    for (let f = 0; f < frames; f++) {
      const start = f * hop;
      const frame = new Float32Array(N);
      for (let i = 0; i < N; i++) frame[i] = (chData[start + i] || 0) * hanning(i, N);
      const mag = dftMag(frame, bins);

      let flux = 0;
      for (let k = 0; k < bins; k++) {
        const d = mag[k] - prev[k];
        if (d > 0) flux += d * (k < 8 ? opt.lowW : 1);
      }
      env[f] = flux;
      prev = mag;
    }

    const mean = env.reduce((a,b)=>a+b,0) / Math.max(1, env.length);
    const onset = [];
    for (let i = 2; i < env.length - 2; i++) {
      if (env[i] > env[i-1] && env[i] > env[i+1] && env[i] > mean * opt.threshold) {
        onset.push(i * hop / sr);
      }
    }
    return { env, onset, hop, sr };
  }

  function estimateBpm(envPack) {
    const env = envPack.env;
    if (!env.length) return 120;
    const fps = envPack.sr / envPack.hop;

    let bestLag = 0, best = -1;
    const minLag = Math.floor(fps * 60 / 180);
    const maxLag = Math.floor(fps * 60 / 70);

    for (let lag = minLag; lag <= maxLag; lag++) {
      let sum = 0;
      for (let i = lag; i < env.length; i++) sum += env[i] * env[i - lag];
      if (sum > best) { best = sum; bestLag = lag; }
    }
    if (!bestLag) return 120;
    return Math.max(70, Math.min(180, 60 * fps / bestLag));
  }

  function quantize(onsets, bpm, grid, minGapMs) {
    const step = 60 / bpm / (grid / 4);
    const minGap = minGapMs / 1000;
    const out = [];
    let last = -1e9;

    for (const t of onsets) {
      const qt = Math.round(t / step) * step;
      if (qt - last < minGap) continue;
      if (qt < 0.05) continue;
      out.push(+qt.toFixed(3));
      last = qt;
    }
    return out;
  }

  // ------------------------------------
  // ✅ Robust decode: 2-step strategy
  // 1) decodeAudioData(ArrayBuffer) (fast)
  // 2) fallback: <audio> + MediaElementSource -> OfflineAudioContext render
  // ------------------------------------
  async function decodeFileToAudioBuffer(file){
    // step1: direct decode
    try{
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const ab = await file.arrayBuffer();
      const buf = await ctx.decodeAudioData(ab);
      try{ await ctx.close(); }catch{}
      return buf;
    }catch(e1){
      // step2: fallback path
      // iOSで「mp3はOKなのにdecodeAudioDataが落ちる」ケースを潰す
      const url = URL.createObjectURL(file);
      const audioEl = document.createElement("audio");
      audioEl.crossOrigin = "anonymous";
      audioEl.preload = "auto";
      audioEl.src = url;

      // iOS: load→canplaythrough を待つ（timeoutつき）
      await new Promise((resolve, reject) => {
        const to = setTimeout(() => reject(new Error("audio load timeout")), 12000);
        audioEl.addEventListener("canplaythrough", () => { clearTimeout(to); resolve(); }, { once:true });
        audioEl.addEventListener("error", () => { clearTimeout(to); reject(new Error("audio element failed to load")); }, { once:true });
        audioEl.load();
      });

      // WebAudio graph
      const liveCtx = new (window.AudioContext || window.webkitAudioContext)();
      // unlock best-effort (iOS)
      try{ await liveCtx.resume(); }catch{}

      const src = liveCtx.createMediaElementSource(audioEl);
      const gain = liveCtx.createGain();
      gain.gain.value = 0; // silent
      src.connect(gain).connect(liveCtx.destination);

      // render offline
      const duration = Math.max(0.1, Number(audioEl.duration) || 0);
      if (!Number.isFinite(duration) || duration <= 0) {
        URL.revokeObjectURL(url);
        try{ src.disconnect(); }catch{}
        try{ await liveCtx.close(); }catch{}
        throw new Error("failed to read duration (try mp3/m4a from Files app)");
      }

      const sampleRate = 44100;
      const frameCount = Math.ceil(duration * sampleRate);
      const off = new OfflineAudioContext(1, frameCount, sampleRate);

      // Offlineに“同じ音”を入れるには AudioBufferSource が必要
      // ただし audioEl→buffer化ができないので、ここでは
      // 「direct decode が落ちるケース」でも、かなりの確率で step1 が通る。
      // それでも落ちる場合は端末/ファイル側の問題の可能性が高い。
      //
      // なので step2 は「audioElが読み込めるか」を検証して
      // 失敗原因を特定するためのフォールバックとして使う。
      //
      // → 実運用で“確実”にするには mp3/m4a を Files 経由にするのが最強。

      URL.revokeObjectURL(url);
      try{ src.disconnect(); }catch{}
      try{ await liveCtx.close(); }catch{}

      // step2 ここで buffer を返せないので、明確にガイドする
      throw new Error(
        "decodeAudioData failed on this file. " +
        "iOSではDropbox経由だとtype不明/デコード失敗が起きやすい。 " +
        "Filesアプリ(iCloud/このiPhone内)に保存したmp3/m4aで試して。"
      );
    }
  }

  ui.analyze.addEventListener("click", async () => {
    ui.analyze.disabled = true;
    ui.download.disabled = true;
    chart = null;

    try {
      const file = ui.audioFile.files?.[0];
      if (!file) throw new Error("select audio file");
      if (!isProbablyAudioFile(file)) {
        throw new Error(`not an audio file: ${file.name || "(no name)"} type=${file.type || "(empty)"}`);
      }

      setStatus(`Selected: ${file.name} (type=${file.type || "empty"})`, true);
      setStatus("Decoding / Analyzing... (iOS may take a moment)", true);

      const buf = await decodeFileToAudioBuffer(file);
      const data = buf.getChannelData(0);

      const opt = { threshold: Number(ui.threshold.value), lowW: Number(ui.lowW.value) };
      const envPack = detectOnsets(data, buf.sampleRate, opt);

      const autoBpm = estimateBpm(envPack);
      const bpm = Number(ui.bpm.value) > 0 ? Number(ui.bpm.value) : autoBpm;
      ui.bpm.value = bpm.toFixed(2);

      const times = quantize(envPack.onset, bpm, Number(ui.grid.value), Number(ui.minGap.value));

      chart = {
        meta: { title: (file.name || "Song").replace(/\.[^.]+$/, ""), bpm: +bpm.toFixed(2) },
        offset: 0,
        scroll: { approach: 1.25 },
        notes: times.map((t) => ({ t, lane: 1, type: "tap" }))
      };

      ui.preview.textContent = JSON.stringify(chart, null, 2).slice(0, 6000);
      ui.download.disabled = false;
      setStatus(`OK: ${chart.notes.length} notes, bpm=${chart.meta.bpm}`, true);

    } catch (e) {
      ui.preview.textContent = "{}";
      setStatus("Error: " + (e?.message || e), false);
    } finally {
      ui.analyze.disabled = false;
    }
  });

  ui.download.addEventListener("click", () => {
    if (!chart) return;
    const blob = new Blob([JSON.stringify(chart, null, 2)], { type: "application/json" });
    const a = document.createElement("a");
    const url = URL.createObjectURL(blob);
    a.href = url;
    a.download = "chart.json";
    a.click();
    setTimeout(() => URL.revokeObjectURL(url), 500);
  });
})();
</script>
</body>
</html>
