<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>詩韻思想 第二書 ― 響きの構文論</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#0b0b1a" />
  <meta name="description" content="詩韻思想 第二書 ― 響きの構文論 | 言葉が魂に届く“共鳴”の仕組みと実践。詩（形）・韻（響）・祈（帰）を結ぶリズムの設計図。">
  <link rel="icon" href="/assets/icon.png" />
  <link rel="canonical" href="https://reverse-shion.github.io/books/two.html" />


  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Shippori+Mincho:wght@400;600&family=Zen+Kaku+Gothic+New:wght@400;600&display=swap" rel="stylesheet">

  <!-- Site CSS -->
  <link rel="stylesheet" href="/assets/css/style.css">
  <link rel="stylesheet" href="/assets/css/nav.css">
  <link rel="stylesheet" href="/assets/css/book.css">

  <!-- Page-only: 神秘的な光演出（多層グロー＋スパークル） -->
  <style>
    :root{
      /* 配色トークン（好みで調整OK） */
      --glow-gold: rgba(255,215,111,.95);
      --glow-amethyst: rgba(174,138,255,.95);
      --glow-icy: rgba(220,236,255,.95);
      --glow-core: #ffffff;

      /* 光量と速度 */
      --char-interval: 100ms;   /* 1文字の間隔（遅いほど神秘的） */
      --line-delay: 700ms;      /* 行と行の間 */
      --pulse-speed: 2.4s;      /* 呼吸する脈動速度 */
      --spark-size: 0.5em;      /* スパークルの最大サイズ */
    }

    /* ヘッダーは常時追尾＆消えない */
    .header{
      position: fixed !important; top:0; left:0; right:0; z-index:9999;
      transform: translateY(0) !important; opacity:1 !important;
    }
    body{ padding-top: calc(var(--header-h,64px) + env(safe-area-inset-top,0px)) !important; }

    /* タイトルの不自然改行を抑制 */
    h1.book-title{ word-break: keep-all; }
    .nowrap{ white-space: nowrap; }

    /* ====== 文字出現のベース（行） ====== */
    .line{
      opacity: 0; visibility: hidden; transform: translateY(6px);
      transition: opacity .5s ease, transform .5s ease, visibility 0s linear .5s;
    }
    .line.visible{
      opacity: 1; visibility: visible; transform: translateY(0);
    }

    /* ====== 1文字ずつ発光しながら出る ====== */
    .char{
      opacity: 0; display: inline-block; transform: translateY(6px);
      /* 中心から金→紫→白の多層グロー（文字が光源に見える） */
      text-shadow:
        0 0 .6px var(--glow-core),
        0 0 2px var(--glow-core),
        0 0 6px var(--glow-icy),
        0 0 12px var(--glow-amethyst),
        0 0 18px var(--glow-gold);
      /* 文字自体にグラデーションを薄く載せて神域感 */
      background: linear-gradient(180deg, #fff 0%, #f9f6ff 40%, #f3eeff 70%, #ffffff 100%);
      -webkit-background-clip: text; background-clip: text; color: transparent;

      animation: charIn .45s cubic-bezier(.22,.61,.36,1) forwards,
                 charPulse var(--pulse-speed) ease-in-out infinite;
      animation-delay: var(--d, 0s);
      position: relative;
    }
    @keyframes charIn{
      0% { opacity:0; transform: translateY(6px) scale(.98) }
      60%{ opacity:1; transform: translateY(0)   scale(1.00) }
      100%{ opacity:1; transform: translateY(0)   scale(1.00) }
    }
    /* 微弱な呼吸（明滅）の脈動。光量がわずかに上下して“生きた文字”に */
    @keyframes charPulse{
      0%  { filter: brightness(1) drop-shadow(0 0 2px var(--glow-icy)); }
      50% { filter: brightness(1.06) drop-shadow(0 0 6px var(--glow-amethyst)); }
      100%{ filter: brightness(1) drop-shadow(0 0 2px var(--glow-icy)); }
    }

    /* ====== スパークル（粒光）：各文字の上で微小に瞬く ====== */
    .char::after{
      content:""; position:absolute; left:50%; top:0.35em;
      width: 0; height: 0; border-radius: 999px; pointer-events: none;
      background:
        radial-gradient(circle, var(--glow-core) 0%, var(--glow-gold) 40%, rgba(255,255,255,0) 60%);
      opacity: 0;
      transform: translateX(-50%) translateY(-50%) scale(0.6);
      animation: spark var(--pulse-speed) ease-in-out infinite;
      animation-delay: calc(var(--d, 0s) + var(--r, 0s));
      filter: blur(.2px);
    }
    @keyframes spark{
      0%,68% { opacity: 0; width:0; height:0; }
      70%    { opacity: .8; width: calc(var(--spark-size) * .25); height: calc(var(--spark-size) * .25); }
      78%    { opacity: 1;  width: calc(var(--spark-size) * .5 ); height: calc(var(--spark-size) * .5 ); }
      85%    { opacity: .0; width: 0; height: 0; }
      100%   { opacity: 0; width: 0; height: 0; }
    }

    /* タブの見た目（軽調整） */
    .mode-switch{ display:flex; gap:14px; margin:12px 0 16px; }
    .mode-switch [role="tab"]{
      min-height:40px; padding:8px 16px; border-radius:999px; border:1px solid rgba(126,102,255,.25);
      background:#fff; font:500 14px/1 "Zen Kaku Gothic New",system-ui,sans-serif;
    }
    .mode-switch [aria-selected="true"]{
      box-shadow:0 0 0 2px rgba(126,102,255,.25) inset; color:#6d57f0;
    }

    /* 動きを抑制したい人の設定尊重 */
    @media (prefers-reduced-motion: reduce){
      .char, .char::after{ animation: none !important; opacity: 1 !important; transform: none !important; }
      .line{ opacity:1 !important; visibility: visible !important; transform:none !important; }
    }
  </style>
</head>

<body>
  
<body class="theme-cosmic">
  
  <!-- ===== Header ===== -->
  <header class="header" role="banner">
    <div class="header-inner">
      <a href="/" class="logo">Re:verse Shion</a>
      <nav class="nav-main" role="navigation" aria-label="メインナビゲーション">
        <a href="/philosophy.html" title="言葉が魂を救う“哲学”の核を読む">思想を読む</a>
        <a href="/philosophy.html#books" title="零〜12＋結の一覧へ">書を探す</a>
        <a href="/story.html" title="TAROT BREAKERの第一話から体験へ">物語に触れる</a>
        <a href="/join.html" title="LINE・noteで最新の詩・配信へ">あなたも加わる</a>
      </nav>
    </div>
  </header>

  <!-- ===== Main ===== -->

<main class="book-wrapper" id="main">
    <h1 class="book-title">詩韻思想&nbsp;第二書&nbsp;—&nbsp;<span class="nowrap">響きの構文論</span></h1>
    <p class="book-subtitle">Shion Philosophy Vol.2 — Re:Song Syntax</p>

    <!-- タブ -->
    <div class="mode-switch" role="tablist" aria-label="表示モード切替">
      <button id="tab-poem" role="tab" aria-controls="panel-poem" aria-selected="true">詩</button>
      <button id="tab-canon" role="tab" aria-controls="panel-canon" aria-selected="false">構文</button>
      <button id="tab-comment" role="tab" aria-controls="panel-comment" aria-selected="false">共鳴</button>
    </div>

    <!-- 本文 -->
    <article class="book-body">
      <!-- 詩 -->
      <section id="panel-poem" role="tabpanel" aria-labelledby="tab-poem" class="mode mode--poem">
        <p class="line">ひとつの言葉が、胸に触れた。</p>
        <p class="line">触れた場所から、波紋が生まれる。</p>
        <p class="line">波紋は重なり、やがて“あなた”と“わたし”の間に、</p>
        <p class="line">見えない橋をかけた。</p>
        <p class="line">それを、私たちは「響き」と呼ぶ。</p>
        <p class="line">意味だけでは届かないものを、</p>
        <p class="line">呼吸のリズムが運んでいく。</p>
      </section>

      <!-- 構文 -->
      <section id="panel-canon" role="tabpanel" aria-labelledby="tab-canon" class="mode mode--canon" hidden>
  <p class="line">言葉は、沈黙の延長である。</p>
  <p class="line">沈黙が形を欲したとき、それは音となり、</p>
  <p class="line">音が他者を求めたとき、それは響きとなる。</p>
  <p class="line">響きは、意味と感情のあわいに揺れながら、</p>
  <p class="line">ふたつの魂を、ひとつの呼吸で結ぶ。</p>
  <p class="line">ゆえに――</p>
  <p class="line">言葉とは、孤独の癒しであり、魂の再結合の術なり。</p>
  <p class="line">その波紋が「共鳴（Re:Song）」であり、</p>
  <p class="line">言葉が他者と世界へ波及する仕組みそのものである。</p>
  <p class="line">詩（形）は心を映し、韻（響）は体を動かし、祈（帰）は光へと還す。</p>
  <p class="line">すべての言葉は、再び沈黙へ帰るために生まれている。</p>
</section>

      <!-- 共鳴 -->
      <section id="panel-comment" role="tabpanel" aria-labelledby="tab-comment" class="mode mode--comment" hidden>
        <p class="line"><strong>要旨：</strong>響きの構文は、言葉を「伝える」から「届く」へ移す設計図。キーワードは<strong>テンポ／間／反復</strong>。</p>
        <p class="line"><strong>ワーク（3分）：</strong>今日の一行を決める → 3回声に出す（または黙読） → そのまま10秒沈黙し、胸の鼓動を聴く。</p>
        <p class="line"><strong>テンプレ：</strong>「私は ______ を選ぶ。今日、最初の一歩は ______ 。」</p>
        <p class="line"><strong>実践のコツ：</strong>朝と夜で同じ一行を反復。テンポは一定、句読点で呼吸。週末に一行を更新し、詩→韻→祈の循環を刻む。</p>
        <p class="line"><strong>祈り：</strong>届いた響きが、やがて誰かの光になるように。言葉は渡し、結果は手放す。「道は開かれた。大丈夫だよ。」</p>
      </section>
    </article>

    <a href="#main" class="to-top" aria-label="ページ上部へ戻る">↑ TOP</a>
  </main>

  <footer class="footer">
    <p>© Re:verse Shion / 詩韻思想</p>
  </footer>

  <!-- ===== JS：1文字ずつ＋行ごと順次（スパーク用ランダム遅延付与） ===== -->
  <script>
    (function(){
      const CHAR_INTERVAL = 55; // 文字の間隔（ms） ← ゆっくり
      const LINE_DELAY    = 280; // 行と行の間（ms）

      function splitToChars(line, baseDelaySec){
        const text = line.textContent;
        line.textContent = "";
        const frag = document.createDocumentFragment();
        for(let i=0;i<text.length;i++){
          const span = document.createElement('span');
          span.className = 'char';
          span.textContent = text[i];
          // 文字ごとの遅延（CSS変数で渡す）
          const charDelaySec = baseDelaySec + (i * (CHAR_INTERVAL/1000));
          span.style.setProperty('--d', charDelaySec + 's');
          // スパークの個体差（0〜0.9sのランダム）
          span.style.setProperty('--r', (Math.random()*0.9).toFixed(2) + 's');
          frag.appendChild(span);
        }
        line.appendChild(frag);
      }

      function revealSequential(panel){
        if(!panel) return;
        const lines = Array.from(panel.querySelectorAll('.line'));
        // リセット
        lines.forEach(l => {
          l.classList.remove('visible');
          const raw = l.textContent;      // 元テキストを保存して
          l.textContent = raw;            // 既存charをクリア
        });

        let t = 0; // 秒で管理（CSSに渡しやすい）
        lines.forEach(line => {
          // 先に分解→ディレイ設定
          splitToChars(line, t);
          // lineの表示タイミング
          setTimeout(() => line.classList.add('visible'), t*1000 - 50);
          // 次行までの遅延＝この行の文字時間＋行ディレイ
          const len = line.textContent.length;
          t += (len * (CHAR_INTERVAL/1000)) + (LINE_DELAY/1000);
        });
      }

      function activateTab(btn){
        const targetId = btn.getAttribute('aria-controls');
        document.querySelectorAll('[role="tab"]').forEach(b =>
          b.setAttribute('aria-selected', b === btn ? 'true' : 'false')
        );
        document.querySelectorAll('[role="tabpanel"]').forEach(p =>
          p.toggleAttribute('hidden', p.id !== targetId)
        );
        revealSequential(document.getElementById(targetId));
      }

      function setupTabsAndInit(){
        // 初期表示：可視パネルだけ実行
        const initialPanel = document.querySelector('.mode:not([hidden])');
        revealSequential(initialPanel);

        // タブ切替
        document.querySelector('.mode-switch')?.addEventListener('click', e => {
          const btn = e.target.closest('[role="tab"]');
          if(btn) activateTab(btn);
        });
      }

      document.addEventListener('DOMContentLoaded', setupTabsAndInit);
    })();
  </script>
  
</body>
</html>
